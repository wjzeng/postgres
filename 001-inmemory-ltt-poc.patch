From 775538c3bfe8fdd02230d69d4e48de817ed21718 Mon Sep 17 00:00:00 2001
From: "wenjing.zwj" <wjzeng2012@gmail.com>
Date: Fri, 12 May 2023 23:40:07 +0800
Subject: [PATCH] fix

---
 src/backend/access/heap/heapam.c              |   54 +-
 src/backend/access/heap/heapam_visibility.c   |    3 +
 src/backend/access/index/genam.c              |   65 +-
 src/backend/access/table/tableam.c            |   13 +-
 src/backend/catalog/Makefile                  |    1 +
 src/backend/catalog/indexing.c                |   59 +-
 src/backend/catalog/inmemcatalog.c            | 1486 +++++++++++++++++
 src/backend/commands/explain.c                |    7 +
 src/backend/executor/Makefile                 |    1 +
 src/backend/executor/execAmi.c                |    6 +
 src/backend/executor/execCurrent.c            |    1 +
 src/backend/executor/execProcnode.c           |   10 +
 src/backend/executor/nodeInmemcatalogscan.c   |  203 +++
 src/backend/optimizer/path/allpaths.c         |   21 +-
 src/backend/optimizer/plan/createplan.c       |   27 +-
 src/backend/optimizer/plan/initsplan.c        |    7 +
 src/backend/optimizer/plan/setrefs.c          |    1 +
 src/backend/optimizer/plan/subselect.c        |    1 +
 src/backend/optimizer/util/inherit.c          |   29 +-
 src/backend/optimizer/util/relnode.c          |    1 +
 src/backend/utils/cache/catcache.c            |    7 +
 src/backend/utils/misc/guc_tables.c           |   10 +
 src/backend/utils/misc/postgresql.conf.sample |    2 +
 src/include/access/heapam.h                   |    8 +-
 src/include/access/relscan.h                  |    7 +
 src/include/access/tableam.h                  |    7 +
 src/include/catalog/inmemcatalog.h            |  132 ++
 src/include/executor/nodeInmemcatalogscan.h   |   24 +
 src/include/nodes/execnodes.h                 |    5 +
 src/include/nodes/pathnodes.h                 |    2 +
 src/include/nodes/plannodes.h                 |    5 +
 31 files changed, 2178 insertions(+), 27 deletions(-)
 create mode 100644 src/backend/catalog/inmemcatalog.c
 create mode 100644 src/backend/executor/nodeInmemcatalogscan.c
 create mode 100644 src/include/catalog/inmemcatalog.h
 create mode 100644 src/include/executor/nodeInmemcatalogscan.h

diff --git a/src/backend/access/heap/heapam.c b/src/backend/access/heap/heapam.c
index 0124f37911..65acf54ec1 100644
--- a/src/backend/access/heap/heapam.c
+++ b/src/backend/access/heap/heapam.c
@@ -53,6 +53,7 @@
 #include "access/xlogutils.h"
 #include "catalog/catalog.h"
 #include "commands/vacuum.h"
+#include "catalog/inmemcatalog.h"
 #include "miscadmin.h"
 #include "pgstat.h"
 #include "port/atomics.h"
@@ -73,8 +74,6 @@
 #include "utils/spccache.h"
 
 
-static HeapTuple heap_prepare_insert(Relation relation, HeapTuple tup,
-									 TransactionId xid, CommandId cid, int options);
 static XLogRecPtr log_heap_update(Relation reln, Buffer oldbuf,
 								  Buffer newbuf, HeapTuple oldtup,
 								  HeapTuple newtup, HeapTuple old_key_tuple,
@@ -87,11 +86,6 @@ static Bitmapset *HeapDetermineColumnsInfo(Relation relation,
 static bool heap_acquire_tuplock(Relation relation, ItemPointer tid,
 								 LockTupleMode mode, LockWaitPolicy wait_policy,
 								 bool *have_tuple_lock);
-static void compute_new_xmax_infomask(TransactionId xmax, uint16 old_infomask,
-									  uint16 old_infomask2, TransactionId add_to_xmax,
-									  LockTupleMode mode, bool is_update,
-									  TransactionId *result_xmax, uint16 *result_infomask,
-									  uint16 *result_infomask2);
 static TM_Result heap_lock_updated_tuple(Relation rel, HeapTuple tuple,
 										 ItemPointer ctid, TransactionId xid,
 										 LockTupleMode mode);
@@ -114,7 +108,7 @@ static int	bottomup_sort_and_shrink(TM_IndexDeleteOp *delstate);
 static XLogRecPtr log_heap_new_cid(Relation relation, HeapTuple tup);
 static HeapTuple ExtractReplicaIdentity(Relation relation, HeapTuple tp, bool key_required,
 										bool *copy);
-
+static HeapTuple heap_getnext_ext(TableScanDesc sscan, ScanDirection direction);
 
 /*
  * Each tuple lock mode has a corresponding heavyweight lock, and one or two
@@ -954,7 +948,7 @@ heap_beginscan(Relation relation, Snapshot snapshot,
 	/*
 	 * allocate and initialize scan descriptor
 	 */
-	scan = (HeapScanDesc) palloc(sizeof(HeapScanDescData));
+	scan = (HeapScanDesc) palloc0(sizeof(HeapScanDescData));
 
 	scan->rs_base.rs_rd = relation;
 	scan->rs_base.rs_snapshot = snapshot;
@@ -1091,6 +1085,36 @@ heap_endscan(TableScanDesc sscan)
 
 HeapTuple
 heap_getnext(TableScanDesc sscan, ScanDirection direction)
+{
+	HeapTuple tuple = NULL;
+
+	if (!sscan->inmem_started)
+	{
+		tuple = heap_getnext_ext(sscan, direction);
+		if (tuple)
+			return tuple;
+	}
+
+	if (sscan->inmemonlyscan != NULL)
+		sscan->inmem_started = true;
+
+	if (sscan->inmem_started)
+	{
+		tuple = InMemHeap_GetNext(sscan->inmemonlyscan, direction);
+		if (tuple)
+		{
+			if (in_memory_catalog_log)
+				elog(WARNING, "hint one record from memcatalog %s by heap_getnext", RelationGetRelationName(sscan->rs_rd));
+
+			return tuple;
+		}
+	}
+
+	return NULL;
+}
+
+static HeapTuple
+heap_getnext_ext(TableScanDesc sscan, ScanDirection direction)
 {
 	HeapScanDesc scan = (HeapScanDesc) sscan;
 
@@ -2010,7 +2034,7 @@ heap_insert(Relation relation, HeapTuple tup, CommandId cid,
  * version of the tuple if it was toasted, or the original tuple if not. Note
  * that in any case, the header fields are also set in the original tuple.
  */
-static HeapTuple
+HeapTuple
 heap_prepare_insert(Relation relation, HeapTuple tup, TransactionId xid,
 					CommandId cid, int options)
 {
@@ -4877,7 +4901,7 @@ heap_acquire_tuplock(Relation relation, ItemPointer tid, LockTupleMode mode,
  * window, but it's still possible to end up creating an unnecessary
  * MultiXactId.  Fortunately this is harmless.
  */
-static void
+void
 compute_new_xmax_infomask(TransactionId xmax, uint16 old_infomask,
 						  uint16 old_infomask2, TransactionId add_to_xmax,
 						  LockTupleMode mode, bool is_update,
@@ -5889,6 +5913,7 @@ heap_inplace_update(Relation relation, HeapTuple tuple)
 	HeapTupleHeader htup;
 	uint32		oldlen;
 	uint32		newlen;
+	uint32		pos;
 
 	/*
 	 * For now, we don't allow parallel updates.  Unlike a regular update,
@@ -5901,6 +5926,13 @@ heap_inplace_update(Relation relation, HeapTuple tuple)
 				(errcode(ERRCODE_INVALID_TRANSACTION_STATE),
 				 errmsg("cannot update tuples during a parallel operation")));
 
+	pos = GetMemTuplePosition(relation, &tuple->t_self);
+	if (BlockNumberIsValid(pos))
+	{
+		InMemHeap_Update(relation, tuple, pos, true);
+		return;
+	}
+
 	buffer = ReadBuffer(relation, ItemPointerGetBlockNumber(&(tuple->t_self)));
 	LockBuffer(buffer, BUFFER_LOCK_EXCLUSIVE);
 	page = (Page) BufferGetPage(buffer);
diff --git a/src/backend/access/heap/heapam_visibility.c b/src/backend/access/heap/heapam_visibility.c
index a716001341..42c1881dde 100644
--- a/src/backend/access/heap/heapam_visibility.c
+++ b/src/backend/access/heap/heapam_visibility.c
@@ -116,6 +116,9 @@ static inline void
 SetHintBits(HeapTupleHeader tuple, Buffer buffer,
 			uint16 infomask, TransactionId xid)
 {
+	if (BufferIsInvalid(buffer))
+		return;
+
 	if (TransactionIdIsValid(xid))
 	{
 		/* NB: xid must be known committed here! */
diff --git a/src/backend/access/index/genam.c b/src/backend/access/index/genam.c
index 722927aeba..06fb5c2256 100644
--- a/src/backend/access/index/genam.c
+++ b/src/backend/access/index/genam.c
@@ -25,6 +25,7 @@
 #include "access/tableam.h"
 #include "access/transam.h"
 #include "catalog/index.h"
+#include "catalog/inmemcatalog.h"
 #include "lib/stringinfo.h"
 #include "miscadmin.h"
 #include "storage/bufmgr.h"
@@ -62,6 +63,8 @@
  * ----------------------------------------------------------------
  */
 
+static HeapTuple systable_getnext_ext(SysScanDesc sysscan);
+
 /* ----------------
  *	RelationGetIndexScan -- Create and fill an IndexScanDesc.
  *
@@ -82,7 +85,7 @@ RelationGetIndexScan(Relation indexRelation, int nkeys, int norderbys)
 {
 	IndexScanDesc scan;
 
-	scan = (IndexScanDesc) palloc(sizeof(IndexScanDescData));
+	scan = (IndexScanDesc) palloc0(sizeof(IndexScanDescData));
 
 	scan->heapRelation = NULL;	/* may be set later */
 	scan->xs_heapfetch = NULL;
@@ -392,6 +395,9 @@ systable_beginscan(Relation heapRelation,
 {
 	SysScanDesc sysscan;
 	Relation	irel;
+	InMemHeapRelation memheap = NULL;
+	AttrNumber *orig_attnos = NULL;
+	bool		should_store_inmem = CatalogMaybeStoreInMem(heapRelation);
 
 	if (indexOK &&
 		!IgnoreSystemIndexes &&
@@ -405,6 +411,8 @@ systable_beginscan(Relation heapRelation,
 	sysscan->heap_rel = heapRelation;
 	sysscan->irel = irel;
 	sysscan->slot = table_slot_create(heapRelation, NULL);
+	sysscan->inmem_started = false;
+	sysscan->inmemonlyscan = NULL;
 
 	if (snapshot == NULL)
 	{
@@ -423,11 +431,24 @@ systable_beginscan(Relation heapRelation,
 	{
 		int			i;
 
+		if (!IsBootstrapProcessingMode() &&
+			RelationGetRelid(heapRelation) != irel->rd_index->indrelid)
+			elog(ERROR, "systable_beginscan Internal error %u %u", RelationGetRelid(heapRelation), irel->rd_index->indrelid);
+
+		/* save original key attribute numbers in case we need them for an in-memory scan in addition to the index scan */
+		if (should_store_inmem)
+			orig_attnos = palloc0(nkeys * sizeof(AttrNumber));
+
 		/* Change attribute numbers to be index column numbers. */
 		for (i = 0; i < nkeys; i++)
 		{
 			int			j;
 
+			if (should_store_inmem)
+			{
+				Assert(key[i].sk_attno == irel->rd_index->indkey.values[i]);
+				orig_attnos[i] = key[i].sk_attno;
+			}
 			for (j = 0; j < IndexRelationGetNumberOfAttributes(irel); j++)
 			{
 				if (key[i].sk_attno == irel->rd_index->indkey.values[j])
@@ -468,6 +489,16 @@ systable_beginscan(Relation heapRelation,
 	if (TransactionIdIsValid(CheckXidAlive))
 		bsysscan = true;
 
+	/*
+	 * Check if there is in-memory-only tuples.
+	 * In the case of in-memory tuples, there is no need to check for
+	 * this mapping because it would be passed to the segments together
+	 * with the heap tuples.
+	 */
+	memheap = OidGetInMemHeapRelation(heapRelation->rd_id, INMEM_ONLY_MAPPING);
+	if (NULL != memheap)
+		sysscan->inmemonlyscan = InMemHeap_BeginScan(memheap, nkeys, key, orig_attnos, true, snapshot, NULL, true);
+
 	return sysscan;
 }
 
@@ -490,6 +521,25 @@ HandleConcurrentAbort()
 				 errmsg("transaction aborted during system catalog scan")));
 }
 
+HeapTuple
+systable_getnext(SysScanDesc sysscan)
+{
+	HeapTuple	htup = NULL;
+
+	if (!sysscan->inmem_started)
+	{
+		htup = systable_getnext_ext(sysscan);
+
+		if ((NULL == htup) && (NULL != sysscan->inmemonlyscan))
+			sysscan->inmem_started = true;
+	}
+
+	if (sysscan->inmem_started)
+		htup = InMemHeap_GetNext(sysscan->inmemonlyscan, ForwardScanDirection);
+
+	return htup;
+}
+
 /*
  * systable_getnext --- get next tuple in a heap-or-index scan
  *
@@ -502,8 +552,8 @@ HandleConcurrentAbort()
  * XXX: It'd probably make sense to offer a slot based interface, at least
  * optionally.
  */
-HeapTuple
-systable_getnext(SysScanDesc sysscan)
+static HeapTuple
+systable_getnext_ext(SysScanDesc sysscan)
 {
 	HeapTuple	htup = NULL;
 
@@ -567,6 +617,9 @@ systable_recheck_tuple(SysScanDesc sysscan, HeapTuple tup)
 	Snapshot	freshsnap;
 	bool		result;
 
+	if (sysscan->inmem_started)
+		return true;
+
 	Assert(tup == ExecFetchSlotHeapTuple(sysscan->slot, false, NULL));
 
 	/*
@@ -622,6 +675,12 @@ systable_endscan(SysScanDesc sysscan)
 	if (TransactionIdIsValid(CheckXidAlive))
 		bsysscan = false;
 
+	if (sysscan->inmemonlyscan)
+	{
+		InMemHeap_EndScan(sysscan->inmemonlyscan, true);
+		sysscan->inmemonlyscan = NULL;
+	}
+
 	pfree(sysscan);
 }
 
diff --git a/src/backend/access/table/tableam.c b/src/backend/access/table/tableam.c
index a5e6c92f35..b93f4d4fa1 100644
--- a/src/backend/access/table/tableam.c
+++ b/src/backend/access/table/tableam.c
@@ -24,6 +24,7 @@
 #include "access/syncscan.h"
 #include "access/tableam.h"
 #include "access/xact.h"
+#include "catalog/inmemcatalog.h"
 #include "optimizer/plancat.h"
 #include "port/pg_bitutils.h"
 #include "storage/bufmgr.h"
@@ -115,9 +116,19 @@ table_beginscan_catalog(Relation relation, int nkeys, struct ScanKeyData *key)
 	SO_ALLOW_STRAT | SO_ALLOW_SYNC | SO_ALLOW_PAGEMODE | SO_TEMP_SNAPSHOT;
 	Oid			relid = RelationGetRelid(relation);
 	Snapshot	snapshot = RegisterSnapshot(GetCatalogSnapshot(relid));
+	TableScanDesc	desc;
 
-	return relation->rd_tableam->scan_begin(relation, snapshot, nkeys, key,
+	desc = relation->rd_tableam->scan_begin(relation, snapshot, nkeys, key,
 											NULL, flags);
+
+	if (CatalogMaybeStoreInMem(relation))
+	{
+		InMemHeapRelation memheap = OidGetInMemHeapRelation(RelationGetRelid(relation), INMEM_ONLY_MAPPING);
+		if (memheap)
+			desc->inmemonlyscan = InMemHeap_BeginScan(memheap, nkeys, key, NULL, true, snapshot, NULL, false);
+	}
+
+	return desc;
 }
 
 void
diff --git a/src/backend/catalog/Makefile b/src/backend/catalog/Makefile
index a60107bf94..72750790fb 100644
--- a/src/backend/catalog/Makefile
+++ b/src/backend/catalog/Makefile
@@ -20,6 +20,7 @@ OBJS = \
 	heap.o \
 	index.o \
 	indexing.o \
+	inmemcatalog.o \
 	namespace.o \
 	objectaccess.o \
 	objectaddress.o \
diff --git a/src/backend/catalog/indexing.c b/src/backend/catalog/indexing.c
index feddff654e..427b9fdf22 100644
--- a/src/backend/catalog/indexing.c
+++ b/src/backend/catalog/indexing.c
@@ -21,6 +21,7 @@
 #include "access/xact.h"
 #include "catalog/index.h"
 #include "catalog/indexing.h"
+#include "catalog/inmemcatalog.h"
 #include "executor/executor.h"
 #include "utils/rel.h"
 
@@ -236,6 +237,12 @@ CatalogTupleInsert(Relation heapRel, HeapTuple tup)
 
 	CatalogTupleCheckConstraints(heapRel, tup);
 
+	if (IsTupleShouldStoreInMemCatalog(heapRel, tup))
+	{
+		InMemHeap_Insert(heapRel, tup);
+		return;
+	}
+
 	indstate = CatalogOpenIndexes(heapRel);
 
 	simple_heap_insert(heapRel, tup);
@@ -258,6 +265,12 @@ CatalogTupleInsertWithInfo(Relation heapRel, HeapTuple tup,
 {
 	CatalogTupleCheckConstraints(heapRel, tup);
 
+	if (IsTupleShouldStoreInMemCatalog(heapRel, tup))
+	{
+		InMemHeap_Insert(heapRel, tup);
+		return;
+	}
+
 	simple_heap_insert(heapRel, tup);
 
 	CatalogIndexInsert(indstate, tup, TU_All);
@@ -273,10 +286,32 @@ void
 CatalogTuplesMultiInsertWithInfo(Relation heapRel, TupleTableSlot **slot,
 								 int ntuples, CatalogIndexState indstate)
 {
+	bool	in_mem_catalog = false;
+
 	/* Nothing to do */
 	if (ntuples <= 0)
 		return;
 
+	for (int i = 0; i < ntuples; i++)
+	{
+		bool		should_free;
+		HeapTuple	tuple;
+
+		tuple = ExecFetchSlotHeapTuple(slot[i], true, &should_free);
+		tuple->t_tableOid = slot[i]->tts_tableOid;
+		if (IsTupleShouldStoreInMemCatalog(heapRel, tuple))
+		{
+			InMemHeap_Insert(heapRel, tuple);
+			in_mem_catalog = true;
+		}
+
+		if (should_free)
+			heap_freetuple(tuple);
+	}
+
+	if (in_mem_catalog)
+		return;
+
 	heap_multi_insert(heapRel, slot, ntuples,
 					  GetCurrentCommandId(true), 0, NULL);
 
@@ -314,9 +349,17 @@ CatalogTupleUpdate(Relation heapRel, ItemPointer otid, HeapTuple tup)
 {
 	CatalogIndexState indstate;
 	TU_UpdateIndexes updateIndexes = TU_All;
+	uint32		pos;
 
 	CatalogTupleCheckConstraints(heapRel, tup);
 
+	pos = GetMemTuplePosition(heapRel, otid);
+	if (BlockNumberIsValid(pos))
+	{
+		InMemHeap_Update(heapRel, tup, pos, false);
+		return;
+	}
+
 	indstate = CatalogOpenIndexes(heapRel);
 
 	simple_heap_update(heapRel, otid, tup, &updateIndexes);
@@ -338,9 +381,17 @@ CatalogTupleUpdateWithInfo(Relation heapRel, ItemPointer otid, HeapTuple tup,
 						   CatalogIndexState indstate)
 {
 	TU_UpdateIndexes updateIndexes = TU_All;
+	uint32 	pos;
 
 	CatalogTupleCheckConstraints(heapRel, tup);
 
+	pos = GetMemTuplePosition(heapRel, otid);
+	if (BlockNumberIsValid(pos))
+	{
+		InMemHeap_Update(heapRel, tup, pos, false);
+		return;
+	}
+
 	simple_heap_update(heapRel, otid, tup, &updateIndexes);
 
 	CatalogIndexInsert(indstate, tup, updateIndexes);
@@ -364,5 +415,11 @@ CatalogTupleUpdateWithInfo(Relation heapRel, ItemPointer otid, HeapTuple tup,
 void
 CatalogTupleDelete(Relation heapRel, ItemPointer tid)
 {
-	simple_heap_delete(heapRel, tid);
+	uint32	pos;
+
+	pos = GetMemTuplePosition(heapRel, tid);
+	if (BlockNumberIsValid(pos))
+		InMemHeap_Delete(heapRel, pos);
+	else
+		simple_heap_delete(heapRel, tid);
 }
diff --git a/src/backend/catalog/inmemcatalog.c b/src/backend/catalog/inmemcatalog.c
new file mode 100644
index 0000000000..578dc9abfb
--- /dev/null
+++ b/src/backend/catalog/inmemcatalog.c
@@ -0,0 +1,1486 @@
+/*-------------------------------------------------------------------------
+ *
+ * inmemcatalog.c
+ * in-memory heap table access method
+ *
+ *-------------------------------------------------------------------------
+ */
+
+#include "postgres.h"
+
+#include "access/genam.h"
+#include "access/heapam.h"
+#include "access/htup.h"
+#include "access/relation.h"
+#include "access/valid.h"
+#include "access/xact.h"
+#include "catalog/catalog.h"
+#include "catalog/index.h"
+#include "catalog/pg_sequence.h"
+#include "catalog/pg_constraint.h"
+#include "catalog/pg_depend.h"
+#include "catalog/pg_namespace.h"
+#include "catalog/pg_type.h"
+#include "catalog/pg_attrdef.h"
+#include "catalog/pg_publication.h"
+#include "catalog/pg_publication_namespace.h"
+#include "catalog/pg_publication_rel.h"
+#include "catalog/inmemcatalog.h"
+#include "common/hashfn.h"
+#include "nodes/memnodes.h"
+#include "nodes/parsenodes.h"
+#include "storage/lock.h"
+#include "utils/fmgroids.h"
+#include "utils/hsearch.h"
+#include "utils/inval.h"
+#include "utils/lsyscache.h"
+#include "utils/memutils.h"
+#include "utils/rel.h"
+#include "utils/snapmgr.h"
+#include "miscadmin.h"
+
+bool		in_memory_catalog_log = false;
+HTAB	   *OidInMemMappings[INMEM_MAPPINGS_SIZE] = {NULL};
+static MemoryContext InMemMappingCxt[INMEM_MAPPINGS_SIZE] = {NULL};
+static const char *InMemMappingNames[INMEM_MAPPINGS_SIZE] = {"OidInMemOnlyMapping"};
+
+#define HeapTupleGetOid(tuple) \
+		HeapTupleHeaderGetOidOld((tuple)->t_data)
+
+#define HeapTupleHeaderGetOidOld(tup) \
+( \
+	((tup)->t_infomask & HEAP_HASOID_OLD) ? \
+	   *((Oid *) ((char *)(tup) + (tup)->t_hoff - sizeof(Oid))) \
+	: \
+		InvalidOid \
+)
+
+typedef bool (*CheckConstraintsFn) (InMemHeapRelation relation, HeapTuple newTuple);
+
+static void InitOidInMemHeapMapping(long initSize, MemoryContext memcxt, InMemMappingType mappingType);
+static bool TypeInMemCatalog(Datum typeid);
+static bool RelationInMemCatalog(Datum relid);
+static bool ConstraintInMemCatalog(Datum cid);
+static bool IndexInMemCatalog(Datum indexid);
+static bool AttrDefaultInMemCatalog(Datum attrdid);
+static bool NamespaceInMemCatalog(Datum nspid);
+static uint32 AllocInMemoryCatalogInsertPosition(InMemHeapRelation inmemrel);
+static bool InMemHeap_GetNextIndex(InMemHeapScanDesc scan, ScanDirection direction);
+static uint32 GetTuplePositionByKeyAttr(InMemHeapRelation inmemtype, AttrNumber keyattr1, Datum key1, AttrNumber keyattr2, Datum key2);
+static HeapTuple heaptuple_copy_to(HeapTuple tup, HeapTuple result, uint32 *len);
+static bool InMemHeap_CheckConstraints(InMemHeapRelation relation, HeapTuple newTuple);
+static bool CheckInMemConstraintsPgNamespace(InMemHeapRelation relation, HeapTuple newTuple);
+static bool CheckInMemConstraintsPgClass(InMemHeapRelation relation, HeapTuple newTuple);
+static bool CheckInMemConstraintsPgType(InMemHeapRelation relation, HeapTuple newTuple);
+static bool CheckInMemConstraintsPgAttribute(InMemHeapRelation relation, HeapTuple newTuple);
+static bool tuple_has_oid(HeapTuple tuple);
+
+static HeapTuple
+heaptuple_copy_to(HeapTuple tuple, HeapTuple dest, uint32 *destlen)
+{
+	HeapTuple	newTuple;
+	uint32		len;
+
+	if (!HeapTupleIsValid(tuple) || tuple->t_data == NULL)
+		return NULL;
+
+/* 	Assert(!is_heaptuple_memtuple(tuple)); */
+
+	len = HEAPTUPLESIZE + tuple->t_len;
+	if (destlen && *destlen < len)
+	{
+		*destlen = len;
+		return NULL;
+	}
+
+	if (destlen)
+	{
+		*destlen = len;
+		newTuple = dest;
+	}
+	else
+		newTuple = (HeapTuple) palloc0(HEAPTUPLESIZE + tuple->t_len);
+
+	newTuple->t_len = tuple->t_len;
+	ItemPointerSetInvalid(&newTuple->t_self);
+	newTuple->t_data = (HeapTupleHeader) ((char *) newTuple + HEAPTUPLESIZE);
+	memcpy((char *) newTuple->t_data, (char *) tuple->t_data, tuple->t_len);
+
+	return newTuple;
+}
+
+/*
+ * init relid to in-memory table mapping
+ */
+static void
+InitOidInMemHeapMapping(long initSize, MemoryContext memcxt, InMemMappingType mappingType)
+{
+	HASHCTL		info;
+
+	Assert(mappingType < INMEM_MAPPINGS_SIZE);
+	Assert(NULL == OidInMemMappings[mappingType]);
+
+	info.hcxt = memcxt;
+	info.hash = oid_hash;
+	info.keysize = sizeof(Oid);
+	info.entrysize = sizeof(struct OidInMemHeapMappingEntry);
+
+	OidInMemMappings[mappingType] = hash_create(InMemMappingNames[mappingType], initSize, &info,
+												HASH_CONTEXT | HASH_FUNCTION | HASH_ELEM);
+
+	Assert(NULL != OidInMemMappings[mappingType]);
+
+	InMemMappingCxt[mappingType] = memcxt;
+}
+
+/*
+ * cleanup relid to in-memory table mapping
+ */
+void
+CleanupOidInMemHeapMapping(InMemMappingType mappingType)
+{
+	Assert(mappingType < INMEM_MAPPINGS_SIZE);
+
+	if (NULL == OidInMemMappings[mappingType])
+	{
+		return;
+	}
+
+	hash_destroy(OidInMemMappings[mappingType]);
+	OidInMemMappings[mappingType] = NULL;
+
+	InMemMappingCxt[mappingType] = NULL;
+}
+
+/*
+ * get a in-memory table by relid,
+ */
+InMemHeapRelation
+OidGetInMemHeapRelation(Oid relid, InMemMappingType mappingType)
+{
+	bool		found = false;
+	struct OidInMemHeapMappingEntry *retval;
+
+	Assert(mappingType < INMEM_MAPPINGS_SIZE);
+
+	if (NULL != OidInMemMappings[mappingType])
+	{
+		retval = hash_search(OidInMemMappings[mappingType], &relid, HASH_FIND, &found);
+		if (NULL != retval)
+		{
+			return retval->rel;
+		}
+	}
+
+	return NULL;
+}
+
+/*
+ * create a in-memory heap table with Oid.
+ * the in-memory table and all its tuples are in memcxt memory context.
+ * at first, initSize tuples space will be alloced in the tuple,
+ * and will re-alloc at runtime if inserting more tuples.
+ */
+InMemHeapRelation
+InMemHeap_Create(Oid relid, Relation rel,
+				 int32 initSize, const char *relname, bool createIndex, int keyAttrno,
+				 InMemMappingType mappingType)
+{
+	bool		found = false;
+	struct OidInMemHeapMappingEntry *entry;
+	InMemHeapRelation memheap = NULL;
+	MemoryContext oldcxt;
+	static MemoryContext InMemoryContext = NULL;
+
+	if (!InMemoryContext)
+	{
+		InMemoryContext = AllocSetContextCreate(CacheMemoryContext,
+												"InMemoryContext",
+												ALLOCSET_DEFAULT_MINSIZE,
+												ALLOCSET_DEFAULT_INITSIZE,
+												ALLOCSET_DEFAULT_MAXSIZE);
+
+		InitOidInMemHeapMapping(10, InMemoryContext, INMEM_ONLY_MAPPING);
+	}
+
+	Assert(mappingType < INMEM_MAPPINGS_SIZE);
+	Assert(NULL != OidInMemMappings[mappingType]);
+
+	hash_search(OidInMemMappings[mappingType], &relid, HASH_FIND, &found);
+
+	if (found)
+	{
+		ereport(ERROR,
+				(errcode(ERRCODE_INTERNAL_ERROR),
+				 errmsg("in-memory table with Oid = %d already exist.", relid)));
+	}
+
+	Assert(MemoryContextIsValid(InMemMappingCxt[mappingType]));
+	oldcxt = MemoryContextSwitchTo(InMemMappingCxt[mappingType]);
+	memheap = palloc0(sizeof(InMemHeapRelationData));
+
+	memheap->memcxt = InMemMappingCxt[mappingType];
+	memheap->relid = relid;
+	memheap->tupsize = 0;
+	memheap->tupmaxsize = initSize;
+	memheap->tuples = NULL;
+	memheap->tupledesc = palloc(TupleDescSize(RelationGetDescr(rel)));
+	TupleDescCopy(memheap->tupledesc, RelationGetDescr(rel));
+
+	memheap->hashIndex = NULL;
+	memheap->keyAttrno = 0;
+	memheap->freelist = NIL;
+	snprintf(memheap->relname, NAMEDATALEN, "%s", relname);
+
+	Assert(!createIndex);
+#if 0
+	if (createIndex)
+	{
+		HASHCTL		info;
+
+		memheap->keyAttrno = keyAttrno;
+
+		/* Set key and entry sizes. */
+		MemSet(&info, 0, sizeof(info));
+		info.keysize = sizeof(Oid);
+		info.entrysize = sizeof(MemHeapHashIndexEntry);
+		info.hash = oid_hash;
+		info.hcxt = memheap->memcxt;
+
+		memheap->hashIndex = hash_create("InMemHeap hash index",
+										 10, &info,
+										 HASH_ELEM | HASH_FUNCTION | HASH_CONTEXT);
+	}
+#endif
+
+	initSize = initSize > 1 ? initSize : 1;
+	memheap->tuples = palloc(sizeof(InMemHeapTupleData) * initSize);
+
+	entry = hash_search(OidInMemMappings[mappingType], &relid, HASH_ENTER, &found);
+
+	entry->relid = relid;
+	entry->rel = memheap;
+
+	MemoryContextSwitchTo(oldcxt);
+
+	return memheap;
+}
+
+/*
+ * drop a in-memory heap table.
+ */
+void
+InMemHeap_Drop(Oid relid, InMemMappingType mappingType)
+{
+	bool		found = false;
+	struct OidInMemHeapMappingEntry *entry = NULL;
+
+	Assert(mappingType < INMEM_MAPPINGS_SIZE);
+	Assert(NULL != OidInMemMappings[mappingType]);
+
+	entry = hash_search(OidInMemMappings[mappingType], &relid, HASH_FIND, &found);
+
+	if (NULL == entry)
+	{
+		return;
+	}
+
+	Assert(NULL != entry->rel);
+
+#if 0
+	if (entry->rel->hashIndex)
+	{
+		hash_destroy(entry->rel->hashIndex);
+		entry->rel->hashIndex = NULL;
+	}
+#endif
+
+	if (entry->rel->tuples)
+	{
+		int			i;
+		HeapTuple	tup;
+
+		for (i = 0; i < entry->rel->tupsize; ++i)
+		{
+			tup = entry->rel->tuples[i].tuple;
+			if (tup)
+			{
+				pfree(tup);
+			}
+		}
+		pfree(entry->rel->tuples);
+	}
+
+	pfree(entry->rel);
+
+	hash_search(OidInMemMappings[mappingType], &relid, HASH_REMOVE, &found);
+}
+
+/*
+ * drop all in-memory tables of given mapping
+ */
+void
+InMemHeap_DropAll(InMemMappingType mappingType)
+{
+	HASH_SEQ_STATUS scan;
+	struct OidInMemHeapMappingEntry *entry;
+
+	Assert(mappingType < INMEM_MAPPINGS_SIZE);
+
+	if (NULL == OidInMemMappings[mappingType])
+	{
+		return;
+	}
+
+	elog(DEBUG1, "Dropping in memory mapping %s", InMemMappingNames[mappingType]);
+
+	hash_seq_init(&scan, OidInMemMappings[mappingType]);
+
+	while (!!(entry = (struct OidInMemHeapMappingEntry *) hash_seq_search(&scan)))
+	{
+		InMemHeap_Drop(entry->relid, mappingType);
+	}
+}
+
+/*
+ * begin a in-memory heap table scan.
+ */
+InMemHeapScanDesc
+InMemHeap_BeginScan(InMemHeapRelation memheap, int nkeys,
+					ScanKey key, AttrNumber *orig_attnos, bool inmemonly,
+					Snapshot snapshot, Relation index, bool addref)
+{
+	InMemHeapScanDesc scan = palloc0(sizeof(InMemHeapScanDescData));
+
+	Assert(NULL != scan);
+
+	scan->rs_snapshot = snapshot;
+
+#if 0
+
+	/*
+	 * The rel in InMemHeapRelation is a pointer, which is the address of heap
+	 * relation in relcache. When the heap relation in relcache is clear for
+	 * some reason, the value of rel in InMemHeapRelation is wrong. So we
+	 * should reopen this relation to make sure it's correct.
+	 */
+	if (addref)
+		memheap->rel = RelationIdGetRelation(memheap->relid);
+#endif
+
+	scan->rs_rd = memheap;
+	scan->rs_nkeys = nkeys;
+	scan->rs_index = -1;
+
+	if (index)
+		scan->index_info = BuildIndexInfo(index);
+
+	if (nkeys > 0)
+		scan->rs_key = (ScanKey) palloc0(sizeof(ScanKeyData) * nkeys);
+	else
+		scan->rs_key = NULL;
+
+	if (key != NULL)
+	{
+		memcpy(scan->rs_key, key, scan->rs_nkeys * sizeof(ScanKeyData));
+		if (NULL != orig_attnos)
+		{
+			/*
+			 * restore original key attribute numbers as the they are invalid
+			 * in the passed array of keys
+			 */
+			/*
+			 * note: the scankey struct contains the attnos of the keys in the
+			 * index scan, and here we need to refer to the original ones from
+			 * the heap relation
+			 */
+			int			i = 0;
+
+			for (i = 0; i < nkeys; i++)
+			{
+				scan->rs_key[i].sk_attno = orig_attnos[i];
+			}
+			scan->orig_attnos = orig_attnos;
+		}
+
+#if 0
+
+		/*
+		 * test if we can use hash index
+		 */
+		if (memheap->hashIndex)
+		{
+			int			i;
+
+			for (i = 0; i < nkeys; ++i)
+			{
+				if (scan->rs_key[i].sk_attno == memheap->keyAttrno
+					&& scan->rs_key[i].sk_strategy == BTEqualStrategyNumber)
+				{
+					/*
+					 * we have a hash index on this attribute
+					 */
+					scan->hashIndexOk = true;
+					scan->hashKeyIndexInScanKey = i;
+					break;
+				}
+			}
+		}
+#endif
+	}
+
+	Assert(inmemonly);
+#if 0
+	if (!inmemonly && (NULL != scan->rs_rd->rel))
+	{
+		/*
+		 * GPSQL-483, GPSQL-486
+		 *
+		 * When a QE exists on the master, we still want to leverage metadata
+		 * that was extracted for query execution via metadata dispatch.
+		 * (Otherwise, we'd have to reintroduce snapshot propagation for some
+		 * sort of bastardized DTM that exists to coordinate the dispatcher
+		 * with a master QE.) In leveraging dispatched metadata on a master
+		 * QE, we also need to ensure that we can't read duplicate metadata
+		 * from the heap itself. To accomplish this, we constrain the fallback
+		 * heap scan to only metadata which could not have been dispatched,
+		 * namely the builtin catalog data. Thus, we add OID < FirstNormalOid
+		 * to the scan key.
+		 */
+
+		int			heap_nkeys = nkeys + 1;
+		ScanKey		heap_key = (ScanKey) palloc0(sizeof(ScanKeyData) * heap_nkeys);
+
+		/* Copy the given input keys */
+		if (NULL != key)
+		{
+			memcpy(heap_key, scan->rs_key, nkeys * sizeof(ScanKeyData));
+		}
+
+		ScanKeyInit(&heap_key[heap_nkeys - 1],
+					ObjectIdAttributeNumber,
+					BTLessStrategyNumber, F_OIDLT,
+					ObjectIdGetDatum(FirstNormalObjectId));
+
+		scan->hscan = heap_beginscan(scan->rs_rd->rel, SnapshotNow,
+									 heap_nkeys, heap_key);
+
+		if (NULL != heap_key)
+		{
+			pfree(heap_key);
+		}
+	}
+#endif
+
+	return scan;
+}
+
+void
+InMemHeap_ReScan(InMemHeapScanDesc scan, ScanKey keys, int nkeys)
+{
+	Assert(NULL != scan);
+
+	scan->rs_index = -1;
+
+	if (scan->rs_nkeys > 0)
+	{
+		Assert(nkeys == scan->rs_nkeys);
+		memmove(scan->rs_key, keys, nkeys * sizeof(ScanKeyData));
+		Assert(memcmp(scan->rs_key, keys, (nkeys * sizeof(ScanKeyData))) == 0);
+
+		if (scan->orig_attnos)
+		{
+			int			i;
+
+			for (i = 0; i < scan->rs_nkeys; i++)
+				scan->rs_key[i].sk_attno = scan->orig_attnos[i];
+
+		}
+	}
+
+	if (in_memory_catalog_log)
+		elog(WARNING, "rescan memcatalog %s", scan->rs_rd->relname);
+}
+
+/*
+ * end a in-memory heap table scan.
+ */
+void
+InMemHeap_EndScan(InMemHeapScanDesc scan, bool closerel)
+{
+	Assert(NULL != scan);
+
+#if 0
+	if (in_memory_catalog_log)
+		elog(WARNING, "endscan memcatalog %s", RelationGetRelationName(scan->rs_rd->rel));
+#endif
+
+#if 0
+	if (closerel)
+		RelationClose(scan->rs_rd->rel);
+#endif
+
+	if (NULL != scan->rs_key)
+	{
+		pfree(scan->rs_key);
+	}
+
+	if (scan->orig_attnos)
+		pfree(scan->orig_attnos);
+
+#if 0
+	if (NULL != scan->hscan)
+	{
+		heap_endscan(scan->hscan);
+	}
+
+	if (NIL != scan->indexReverseList)
+	{
+		list_free(scan->indexReverseList);
+	}
+#endif
+	pfree(scan);
+}
+
+/*
+ * Increment scan->rs_index based on scan direction.
+ * Returns false when scan reaches its end.
+ */
+static bool
+InMemHeap_GetNextIndex(InMemHeapScanDesc scan, ScanDirection direction)
+{
+	if (BackwardScanDirection == direction)
+	{
+		if (-1 == scan->rs_index)	/* scan beginning */
+		{
+			scan->rs_index = scan->rs_rd->tupsize;
+		}
+		scan->rs_index--;
+		return (scan->rs_index > -1);
+	}
+	else
+	{
+		scan->rs_index++;
+		return (scan->rs_index < scan->rs_rd->tupsize);
+	}
+}
+
+/*
+ * get next tuple in in-memory heap table.
+ */
+HeapTuple
+InMemHeap_GetNext(InMemHeapScanDesc scan, ScanDirection direction)
+{
+	bool		valid = true;
+
+	InMemHeapTuple pmemtup = NULL;
+
+	Assert(NULL != scan);
+
+#if 0
+	if (scan->hashIndexOk)
+	{
+		if (false == scan->indexScanInitialized)
+		{
+			Oid			key;
+			bool		found;
+			MemHeapHashIndexEntry *entry;
+
+			key = DatumGetObjectId(scan->rs_key[scan->hashKeyIndexInScanKey].sk_argument);
+
+			entry = (MemHeapHashIndexEntry *) hash_search(scan->rs_rd->hashIndex, &key,
+														  HASH_FIND, &found);
+
+			if (found)
+			{
+				if (BackwardScanDirection == direction)
+				{
+					/* if direction is backward, reverse list */
+					scan->indexReverseList = list_reverse_ints(entry->values);
+					entry->values = scan->indexReverseList;
+				}
+				scan->indexNext = list_head(entry->values);
+			}
+			else
+				scan->indexNext = NULL;
+
+			scan->indexScanInitialized = true;
+			scan->indexScanKey = key;
+		}
+
+		for (; scan->indexNext != NULL;
+			 scan->indexNext = lnext(scan->indexReverseList, scan->indexNext))
+		{
+			int32		index = lfirst_int(scan->indexNext);
+
+			elog(DEBUG1, "read index %d key %d for relation %s", index, scan->indexScanKey, scan->rs_rd->relname);
+
+			pmemtup = &scan->rs_rd->tuples[index];
+
+			if (pmemtup->flags == INMEM_HEAP_TUPLE_IS_NULL)
+				continue;
+			else if (!HeapTupleSatisfiesVisibility(pmemtup->tuple, scan->rs_snapshot, InvalidBuffer))
+				continue;
+
+			valid = HeapKeyTest(pmemtup->tuple, RelationGetDescr(scan->rs_rd->rel),
+								scan->rs_nkeys, scan->rs_key);
+
+			if (!valid)
+			{
+				continue;
+			}
+
+			scan->rs_ctup = pmemtup->tuple;
+			scan->indexNext = lnext(scan->indexReverseList, scan->indexNext);
+			return scan->rs_ctup;
+		}
+	}
+	else
+#endif
+	{
+		/* for backward scan, change direction of iterator */
+		while (InMemHeap_GetNextIndex(scan, direction))
+		{
+			pmemtup = &scan->rs_rd->tuples[scan->rs_index];
+
+			if (pmemtup->flags == INMEM_HEAP_TUPLE_IS_NULL)
+				continue;
+			else if (!HeapTupleSatisfiesVisibility(pmemtup->tuple, scan->rs_snapshot, InvalidBuffer))
+				continue;
+			else if (scan->rs_key != NULL)
+			{
+				valid = HeapKeyTest(pmemtup->tuple, scan->rs_rd->tupledesc,
+									scan->rs_nkeys, scan->rs_key);
+			}
+
+			if (!valid)
+			{
+				continue;
+			}
+
+			scan->rs_ctup = pmemtup->tuple;
+			return scan->rs_ctup;
+		}
+	}
+#if 0
+
+	/*
+	 * read from local read only heap table.
+	 */
+	if (NULL != scan->hscan)
+	{
+		return heap_getnext(scan->hscan, direction);
+	}
+#endif
+	return NULL;
+}
+
+/*
+ * insert a tuple into in-memory heap table.
+ */
+void
+InMemHeap_Insert(Relation relation, HeapTuple tup)
+{
+	InMemHeapTuple inmemtup;
+	InMemHeapRelation inmemrel = NULL;
+	Oid			relid = RelationGetRelid(relation);
+	MemoryContext oldctx;
+	uint32		insert_pos = -1;
+	TransactionId xid = GetCurrentTransactionId();
+	CommandId	cid = GetCurrentCommandId(true);
+
+	Assert(RelationIsValid(relation) && tup);
+	inmemrel = OidGetInMemHeapRelation(relid, INMEM_ONLY_MAPPING);
+	if (!inmemrel)
+	{
+		inmemrel = InMemHeap_Create(relid, relation, 10,
+									RelationGetRelationName(relation), false, 0, INMEM_ONLY_MAPPING);
+	}
+
+	Assert(InMemHeap_CheckConstraints(inmemrel, tup));
+
+	oldctx = MemoryContextSwitchTo(inmemrel->memcxt);
+
+	insert_pos = AllocInMemoryCatalogInsertPosition(inmemrel);
+	inmemtup = &inmemrel->tuples[insert_pos];
+	inmemtup->flags = INMEM_HEAP_TUPLE_DISPATCHED;
+	inmemtup->tuple = heaptuple_copy_to(tup, NULL, NULL);
+
+	Assert(inmemtup->tuple != NULL);
+	Assert(!HeapTupleHasExternal(inmemtup->tuple));
+/* 	Assert(inmemtup->tuple->t_len <= TOAST_TUPLE_THRESHOLD); */
+	inmemtup->tuple = heap_prepare_insert(relation, inmemtup->tuple, xid, cid, 0);
+	ItemPointerSet(&inmemtup->tuple->t_self, insert_pos, MaxOffsetNumber);
+
+#if 0
+	if (inmemrel->hashIndex)
+	{
+		Oid			key;
+		bool		isNull,
+					found;
+		MemHeapHashIndexEntry *entry;
+
+		key = DatumGetObjectId(
+							   heap_getattr(tup, inmemrel->keyAttrno,
+											RelationGetDescr(inmemrel->rel), &isNull));
+
+		Insist(!isNull && "index key cannot be null");
+
+		entry = (MemHeapHashIndexEntry *) hash_search(inmemrel->hashIndex, &key,
+													  HASH_ENTER, &found);
+
+		if (!found)
+		{
+			entry->key = key;
+			entry->values = NIL;
+		}
+
+		entry->values = lappend_int(entry->values, insert_pos);
+
+		elog(DEBUG1, "add index %d key %d relation %s", insert_pos, key, inmemrel->relname);
+	}
+#endif
+
+	MemoryContextSwitchTo(oldctx);
+
+	CacheInvalidateHeapTuple(relation, tup, NULL);
+
+	if (relid == NamespaceRelationId)
+		CommandCounterIncrement();
+}
+
+/*
+ * update a tuple in in-memory heap table.
+ *
+ * if the target tuple already in the memory,
+ * update it in-place with flag INMEM_HEAP_TUPLE_UPDATED.
+ * else report an error.
+ *
+ * update should not change the otid of the old tuple,
+ * since updated tuple should write back to the master and update there.
+ */
+void
+InMemHeap_Update(Relation relation, HeapTuple tup, uint32 position, bool inplace)
+{
+	HeapTuple	target;
+	MemoryContext oldmem;
+	InMemHeapRelation inmemrel;
+	Oid			relid = RelationGetRelid(relation);
+	TransactionId xid = GetCurrentTransactionId();
+	CommandId	cid = GetCurrentCommandId(true);
+
+	Assert(RelationIsValid(relation));
+	Assert(position >= 0);
+	inmemrel = OidGetInMemHeapRelation(relid, INMEM_ONLY_MAPPING);
+	Assert(inmemrel);
+
+	if (position >= inmemrel->tupsize)
+	{
+		ereport(ERROR,
+				(errcode(ERRCODE_INTERNAL_ERROR),
+				 errmsg("update a tuple which does not exist,"
+						" relname = %s, relid = %u", inmemrel->relname,
+						inmemrel->relid)));
+	}
+
+	Assert(inmemrel->hashIndex == NULL);
+	oldmem = MemoryContextSwitchTo(inmemrel->memcxt);
+
+	Assert(inmemrel->tuples[position].flags == INMEM_HEAP_TUPLE_DISPATCHED);
+
+	target = heaptuple_copy_to(tup, NULL, NULL);
+	Assert(target != NULL);
+	target->t_tableOid = relid;
+	Assert(!HeapTupleHasExternal(target));
+/* 	Assert(target->t_len <= TOAST_TUPLE_THRESHOLD); */
+	target = heap_prepare_insert(relation, target, xid, cid, 0);
+
+	if (inplace)
+	{
+		ItemPointerSet(&target->t_self, position, MaxOffsetNumber);
+		CacheInvalidateHeapTuple(relation, inmemrel->tuples[position].tuple, target);
+		pfree(inmemrel->tuples[position].tuple);
+		inmemrel->tuples[position].tuple = target;
+	}
+	else
+	{
+		HeapTuple	oldtup = inmemrel->tuples[position].tuple;
+		TransactionId xmax_old_tuple;
+		uint16		infomask_old_tuple,
+					infomask2_old_tuple;
+		bool		iscombo;
+		uint32		new_pos;
+
+		compute_new_xmax_infomask(HeapTupleHeaderGetRawXmax(oldtup->t_data),
+								  oldtup->t_data->t_infomask,
+								  oldtup->t_data->t_infomask2,
+								  xid, LockTupleNoKeyExclusive, true,
+								  &xmax_old_tuple, &infomask_old_tuple,
+								  &infomask2_old_tuple);
+
+		HeapTupleHeaderAdjustCmax(oldtup->t_data, &cid, &iscombo);
+
+		/* Clear obsolete visibility flags, possibly set by ourselves above... */
+		oldtup->t_data->t_infomask &= ~(HEAP_XMAX_BITS | HEAP_MOVED);
+		oldtup->t_data->t_infomask2 &= ~HEAP_KEYS_UPDATED;
+		/* ... and store info about transaction updating this tuple */
+		Assert(TransactionIdIsValid(xmax_old_tuple));
+		HeapTupleHeaderSetXmax(oldtup->t_data, xmax_old_tuple);
+		oldtup->t_data->t_infomask |= infomask_old_tuple;
+		oldtup->t_data->t_infomask2 |= infomask2_old_tuple;
+		HeapTupleHeaderSetCmax(oldtup->t_data, cid, iscombo);
+
+		new_pos = AllocInMemoryCatalogInsertPosition(inmemrel);
+
+		inmemrel->tuples[new_pos].tuple = target;
+		inmemrel->tuples[new_pos].flags = INMEM_HEAP_TUPLE_DISPATCHED;
+		ItemPointerSet(&target->t_self, new_pos, MaxOffsetNumber);
+		target->t_data->t_infomask |= HEAP_UPDATED;
+
+		CacheInvalidateHeapTuple(relation, inmemrel->tuples[position].tuple, target);
+	}
+
+	MemoryContextSwitchTo(oldmem);
+
+	if (relid == NamespaceRelationId)
+		CommandCounterIncrement();
+}
+
+void
+InMemHeap_Delete(Relation relation, uint32 position)
+{
+	InMemHeapRelation inmemrel;
+	Oid			relid = RelationGetRelid(relation);
+	MemoryContext oldmem;
+	TransactionId xid = GetCurrentTransactionId();
+	CommandId	cid = GetCurrentCommandId(true);
+
+	Assert(RelationIsValid(relation));
+	Assert(position >= 0);
+	inmemrel = OidGetInMemHeapRelation(relid, INMEM_ONLY_MAPPING);
+	Assert(inmemrel);
+
+	if (position >= inmemrel->tupsize)
+	{
+		ereport(ERROR,
+				(errcode(ERRCODE_INTERNAL_ERROR),
+				 errmsg("delete a tuple which does not exist,"
+						" relname = %s, relid = %u", inmemrel->relname,
+						inmemrel->relid)));
+	}
+
+	oldmem = MemoryContextSwitchTo(inmemrel->memcxt);
+
+	Assert(inmemrel->hashIndex == NULL);
+	Assert(inmemrel->tuples[position].flags == INMEM_HEAP_TUPLE_DISPATCHED);
+	Assert(inmemrel->tuples[position].tuple);
+
+#if 0
+	inmemrel->tuples[position].flags = INMEM_HEAP_TUPLE_IS_NULL;
+	pfree(inmemrel->tuples[position].tuple);
+	inmemrel->tuples[position].tuple = NULL;
+	Assert(!list_member_oid(inmemrel->freelist, position));
+	inmemrel->freelist = lappend_oid(inmemrel->freelist, position);
+#endif
+
+	{
+		TransactionId new_xmax;
+		uint16		new_infomask,
+					new_infomask2;
+		bool		iscombo;
+		HeapTuple	oldtup = inmemrel->tuples[position].tuple;
+
+		compute_new_xmax_infomask(HeapTupleHeaderGetRawXmax(oldtup->t_data),
+								  oldtup->t_data->t_infomask, oldtup->t_data->t_infomask2,
+								  xid, LockTupleExclusive, true,
+								  &new_xmax, &new_infomask, &new_infomask2);
+
+		HeapTupleHeaderAdjustCmax(oldtup->t_data, &cid, &iscombo);
+
+		/* store transaction information of xact deleting the tuple */
+		oldtup->t_data->t_infomask &= ~(HEAP_XMAX_BITS | HEAP_MOVED);
+		oldtup->t_data->t_infomask2 &= ~HEAP_KEYS_UPDATED;
+		oldtup->t_data->t_infomask |= new_infomask;
+		oldtup->t_data->t_infomask2 |= new_infomask2;
+		HeapTupleHeaderClearHotUpdated(oldtup->t_data);
+		HeapTupleHeaderSetXmax(oldtup->t_data, new_xmax);
+		HeapTupleHeaderSetCmax(oldtup->t_data, cid, iscombo);
+	}
+
+	MemoryContextSwitchTo(oldmem);
+
+	CacheInvalidateHeapTuple(relation, inmemrel->tuples[position].tuple, NULL);
+
+	if (relid == NamespaceRelationId)
+		CommandCounterIncrement();
+}
+
+/*
+ * CheckInMemConstraintsPgNamespace
+ * 		Check uniqueness constraints for pg_namespace in-memory tuples upon insert
+ */
+static bool
+CheckInMemConstraintsPgNamespace(InMemHeapRelation relation, HeapTuple newTuple)
+{
+	TupleDesc	tupleDesc = relation->tupledesc;
+	char	   *nspnameNew;
+	Oid			newOid;
+	int			i;
+	bool		hasoid;
+
+	Assert(newTuple);
+	Assert(relation);
+	nspnameNew = DatumGetCString(tuple_getattr(newTuple, tupleDesc, Anum_pg_namespace_nspname));
+	newOid = HeapTupleGetOid(newTuple);
+	hasoid = tuple_has_oid(newTuple);
+
+	for (i = 0; i < relation->tupsize; i++)
+	{
+		char	   *nspname;
+		HeapTuple	tuple = relation->tuples[i].tuple;
+
+		if (relation->tuples[i].flags == INMEM_HEAP_TUPLE_IS_NULL)
+			continue;
+
+		if (!HeapTupleSatisfiesVisibility(tuple, SnapshotSelf, InvalidBuffer))
+			continue;
+
+		Assert(tuple);
+		if (hasoid && HeapTupleGetOid(tuple) == newOid)
+			elog(ERROR, "in-memory tuple with Oid = %d already exists in pg_namespace.", newOid);
+
+		nspname = DatumGetCString(tuple_getattr(tuple, tupleDesc, Anum_pg_namespace_nspname));
+		if (pg_strcasecmp(nspname, nspnameNew) == 0)
+			elog(ERROR, "in-memory tuple with nspname = %s already exists in pg_namespace.", nspnameNew);
+	}
+
+	return true;
+}
+
+/*
+ * CheckInMemConstraintsPgClass
+ * 		Check uniqueness constraints for pg_class in-memory tuples upon insert
+ */
+static bool
+CheckInMemConstraintsPgClass(InMemHeapRelation relation, HeapTuple newTuple)
+{
+	TupleDesc	tupleDesc = relation->tupledesc;
+	Oid			relnamespaceNew;
+	char	   *relnameNew;
+	int			i;
+	Oid			newOid;
+	bool		hasoid;
+
+	Assert(newTuple);
+	Assert(relation);
+	relnamespaceNew = DatumGetObjectId(tuple_getattr(newTuple, tupleDesc, Anum_pg_class_relnamespace));
+	relnameNew = DatumGetCString(tuple_getattr(newTuple, tupleDesc, Anum_pg_class_relname));
+	newOid = HeapTupleGetOid(newTuple);
+	hasoid = tuple_has_oid(newTuple);
+
+	for (i = 0; i < relation->tupsize; i++)
+	{
+		Oid			relnamespace;
+		char	   *relname;
+		HeapTuple	tuple = relation->tuples[i].tuple;
+
+		if (relation->tuples[i].flags == INMEM_HEAP_TUPLE_IS_NULL)
+			continue;
+
+		if (!HeapTupleSatisfiesVisibility(tuple, SnapshotSelf, InvalidBuffer))
+			continue;
+
+		Assert(tuple);
+		if (hasoid && HeapTupleGetOid(tuple) == newOid)
+			elog(ERROR, "in-memory tuple with Oid = %d already exists in pg_class.", newOid);
+
+		relnamespace = DatumGetObjectId(tuple_getattr(tuple, tupleDesc, Anum_pg_class_relnamespace));
+		relname = DatumGetCString(tuple_getattr(tuple, tupleDesc, Anum_pg_class_relname));
+		if (relnamespace == relnamespaceNew && pg_strcasecmp(relname, relnameNew) == 0)
+			elog(ERROR, "in-memory tuple with relname = %s and relnamespace = %d already exists in pg_class.", relnameNew, relnamespaceNew);
+	}
+
+	return true;
+}
+
+/*
+ * CheckInMemConstraintsPgType
+ * 		Check uniqueness constraints for pg_type in-memory tuples upon insert
+ */
+static bool
+CheckInMemConstraintsPgType(InMemHeapRelation relation, HeapTuple newTuple)
+{
+	TupleDesc	tupleDesc = relation->tupledesc;
+	Oid			relnamespaceNew;
+	char	   *typnameNew;
+	int			i;
+	Oid			newOid;
+	bool		hasoid;
+
+	Assert(NULL != newTuple);
+	Assert(NULL != relation);
+	relnamespaceNew = DatumGetObjectId(tuple_getattr(newTuple, tupleDesc, Anum_pg_type_typnamespace));
+	typnameNew = DatumGetCString(tuple_getattr(newTuple, tupleDesc, Anum_pg_type_typname));
+	newOid = HeapTupleGetOid(newTuple);
+	hasoid = tuple_has_oid(newTuple);
+
+	for (i = 0; i < relation->tupsize; i++)
+	{
+		Oid			relnamespace;
+		char	   *typname;
+		HeapTuple	tuple = relation->tuples[i].tuple;
+
+		if (relation->tuples[i].flags == INMEM_HEAP_TUPLE_IS_NULL)
+			continue;
+
+		if (!HeapTupleSatisfiesVisibility(tuple, SnapshotSelf, InvalidBuffer))
+			continue;
+
+		Assert(tuple);
+		if (hasoid && HeapTupleGetOid(tuple) == newOid)
+			elog(ERROR, "in-memory tuple with Oid = %d already exists in pg_type.", newOid);
+
+		relnamespace = DatumGetObjectId(tuple_getattr(tuple, tupleDesc, Anum_pg_type_typnamespace));
+		typname = DatumGetCString(tuple_getattr(tuple, tupleDesc, Anum_pg_type_typname));
+		if ((relnamespace == relnamespaceNew && pg_strcasecmp(typname, typnameNew) == 0))
+			elog(ERROR, "in-memory tuple with typname = %s and typnamespace = %d already exists in pg_type.", typnameNew, relnamespaceNew);
+	}
+
+	return true;
+}
+
+/*
+ * CheckInMemConstraintsPgAttribute
+ * 		Check uniqueness constraints for pg_attribute in-memory tuples upon insert
+ */
+static bool
+CheckInMemConstraintsPgAttribute(InMemHeapRelation relation, HeapTuple newTuple)
+{
+	TupleDesc	tupleDesc = relation->tupledesc;
+	Oid			attrelidNew;
+	char	   *attnameNew;
+	AttrNumber	attnoNew;
+	int			i;
+
+	Assert(newTuple);
+	Assert(relation);
+	attrelidNew = DatumGetObjectId(tuple_getattr(newTuple, tupleDesc, Anum_pg_attribute_attrelid));
+	attnameNew = DatumGetCString(tuple_getattr(newTuple, tupleDesc, Anum_pg_attribute_attname));
+	attnoNew = DatumGetInt16((tuple_getattr(newTuple, tupleDesc, Anum_pg_attribute_attnum)));
+
+	for (i = 0; i < relation->tupsize; i++)
+	{
+		HeapTuple	tuple = relation->tuples[i].tuple;
+		Oid			attrelid;
+		char	   *attname;
+		AttrNumber	attno;
+
+		if (relation->tuples[i].flags == INMEM_HEAP_TUPLE_IS_NULL)
+			continue;
+
+		if (!HeapTupleSatisfiesVisibility(tuple, SnapshotSelf, InvalidBuffer))
+			continue;
+
+		Assert(tuple);
+		attrelid = DatumGetObjectId(tuple_getattr(tuple, tupleDesc, Anum_pg_attribute_attrelid));
+		attname = DatumGetCString(tuple_getattr(tuple, tupleDesc, Anum_pg_attribute_attname));
+		attno = DatumGetInt16((tuple_getattr(tuple, tupleDesc, Anum_pg_attribute_attnum)));
+		if (attrelid != attrelidNew)
+			continue;
+
+		if (attno == attnoNew)
+			elog(ERROR, "in-memory tuple with attrelid = %d and attno = %d already exists in pg_attribute.", attrelidNew, attnoNew);
+
+		if (pg_strcasecmp(attname, attnameNew) == 0)
+			elog(ERROR, "in-memory tuple with attrelid = %d and attname = %s already exists in pg_attribute.", attrelidNew, attnameNew);
+	}
+
+	return true;
+}
+
+static bool
+InMemHeap_CheckConstraints(InMemHeapRelation relation, HeapTuple newTuple)
+{
+	Oid			relid = relation->relid;
+	CheckConstraintsFn fn = NULL;
+
+	Assert(relation);
+	Assert(newTuple);
+
+	switch (relid)
+	{
+		case NamespaceRelationId:
+			fn = CheckInMemConstraintsPgNamespace;
+			break;
+		case RelationRelationId:
+			fn = CheckInMemConstraintsPgClass;
+			break;
+		case TypeRelationId:
+			fn = CheckInMemConstraintsPgType;
+			break;
+		case AttributeRelationId:
+			fn = CheckInMemConstraintsPgAttribute;
+			break;
+		default:
+			return true;
+	}
+
+	if (fn)
+		fn(relation, newTuple);
+
+	return true;
+}
+
+/* ----------------
+ *      tuple_getattr
+ *
+ *      Extracts an attribute from a HeapTuple given its attnum and
+ *      returns it as a Datum.
+ *
+ *      <tuple> is the pointer to the heap tuple.  <attnum> is the attribute
+ *      number of the column (field) caller wants.  <tupleDesc> is a
+ *      pointer to the structure describing the row and all its fields.
+ *
+ * ----------------
+ */
+Datum
+tuple_getattr(HeapTuple tuple, TupleDesc tupleDesc, int attnum)
+{
+	bool		isnull;
+	Datum		attr = heap_getattr(tuple, attnum, tupleDesc, &isnull);
+
+	Assert(NULL != tupleDesc);
+	Assert(NULL != tuple);
+	if (isnull)
+		elog(ERROR, "attribute cannot be null in inmem tuple_getattr");
+
+	return attr;
+}
+
+bool
+IsTupleShouldStoreInMemCatalog(Relation relation, HeapTuple newTuple)
+{
+	Oid			relid = RelationGetRelid(relation);
+	TupleDesc	tupleDesc = RelationGetDescr(relation);
+	bool		recordInMemCatalog = false;
+
+	if (IsBootstrapProcessingMode() || !CatalogMaybeStoreInMem(relation))
+		return false;
+
+	switch (relid)
+	{
+		case NamespaceRelationId:
+			{
+				char	   *nspname = DatumGetCString(tuple_getattr(newTuple, tupleDesc, Anum_pg_namespace_nspname));
+
+				recordInMemCatalog = (strncmp(nspname, "pg_temp_", 8) == 0) || (strncmp(nspname, "pg_toast_temp_", 14) == 0);
+			}
+			break;
+		case RelationRelationId:
+			{
+				char		relpersistence = DatumGetChar(tuple_getattr(newTuple, tupleDesc, Anum_pg_class_relpersistence));
+
+				if (relpersistence == RELPERSISTENCE_TEMP)
+				{
+					char	   *relname = DatumGetCString(tuple_getattr(newTuple, tupleDesc, Anum_pg_class_relname));
+					Oid			id = DatumGetObjectId(tuple_getattr(newTuple, tupleDesc, Anum_pg_class_relname));
+
+					recordInMemCatalog = true;
+					if (in_memory_catalog_log)
+						elog(WARNING, "record pg_class %u %s into memcatalog", id, relname);
+				}
+			}
+			break;
+		case TypeRelationId:
+			{
+				Datum		typensp_datum = tuple_getattr(newTuple, tupleDesc, Anum_pg_type_typnamespace);
+
+				if (NamespaceInMemCatalog(typensp_datum))
+					recordInMemCatalog = true;
+			}
+			break;
+		case AttributeRelationId:
+			{
+				Datum		attrelid_datum = tuple_getattr(newTuple, tupleDesc, Anum_pg_attribute_attrelid);
+
+				if (RelationInMemCatalog(attrelid_datum))
+					recordInMemCatalog = true;
+			}
+			break;
+		case IndexRelationId:
+			{
+				Datum		indrelid_datum = tuple_getattr(newTuple, tupleDesc, Anum_pg_index_indrelid);
+
+				if (RelationInMemCatalog(indrelid_datum))
+					recordInMemCatalog = true;
+			}
+			break;
+
+		case ConstraintRelationId:
+			{
+				Datum		conrelid_datum = tuple_getattr(newTuple, tupleDesc, Anum_pg_constraint_conrelid);
+
+				if (RelationInMemCatalog(conrelid_datum))
+					recordInMemCatalog = true;
+			}
+			break;
+
+		case AttrDefaultRelationId:
+			{
+				Datum		attrrelid_datum = tuple_getattr(newTuple, tupleDesc, Anum_pg_attrdef_adrelid);
+
+				if (RelationInMemCatalog(attrrelid_datum))
+					recordInMemCatalog = true;
+			}
+			break;
+
+		case SequenceRelationId:
+			{
+				Datum		seqrelid_datum = tuple_getattr(newTuple, tupleDesc, Anum_pg_sequence_seqrelid);
+
+				if (RelationInMemCatalog(seqrelid_datum))
+					recordInMemCatalog = true;
+			}
+			break;
+
+		case DependRelationId:
+			{
+				Datum		depend_class_datum = tuple_getattr(newTuple, tupleDesc, Anum_pg_depend_classid);
+				Datum		depend_oid_datum = tuple_getattr(newTuple, tupleDesc, Anum_pg_depend_objid);
+				Oid			depend_classid = DatumGetObjectId(depend_class_datum);
+
+				if (depend_classid == IndexRelationId &&
+					IndexInMemCatalog(depend_oid_datum))
+					recordInMemCatalog = true;
+				else if (depend_classid == ConstraintRelationId &&
+						 ConstraintInMemCatalog(depend_oid_datum))
+					recordInMemCatalog = true;
+				else if (depend_classid == RelationRelationId &&
+						 RelationInMemCatalog(depend_oid_datum))
+					recordInMemCatalog = true;
+				else if (depend_classid == TypeRelationId &&
+						 TypeInMemCatalog(depend_oid_datum))
+					recordInMemCatalog = true;
+				else if (depend_classid == AttrDefaultRelationId &&
+						 AttrDefaultInMemCatalog(depend_oid_datum))
+					recordInMemCatalog = true;
+			}
+			break;
+
+		default:
+			{
+#if 0
+				if (in_memory_catalog_log)
+					elog(WARNING, "catalog %s tuple not record to memcatalog", get_rel_name(relid));
+#endif
+			}
+			break;
+	}
+
+	if (in_memory_catalog_log && recordInMemCatalog)
+		elog(WARNING, "insert record %s into memcatalog", get_rel_name(relid));
+
+	return recordInMemCatalog;
+}
+
+static bool
+NamespaceInMemCatalog(Datum nspid)
+{
+	InMemHeapRelation inmemrel = OidGetInMemHeapRelation(NamespaceRelationId, INMEM_ONLY_MAPPING);
+	uint32		pos;
+
+	if (!inmemrel || !OidIsValid(DatumGetObjectId(nspid)))
+		return false;
+
+	pos = GetTuplePositionByKeyAttr(inmemrel, Anum_pg_namespace_oid, nspid, InvalidAttrNumber, 0);
+
+	return BlockNumberIsValid(pos);
+}
+
+static bool
+AttrDefaultInMemCatalog(Datum attrdid)
+{
+	InMemHeapRelation inmemrel = OidGetInMemHeapRelation(AttrDefaultRelationId, INMEM_ONLY_MAPPING);
+	uint32		pos;
+
+	if (!inmemrel || !OidIsValid(DatumGetObjectId(attrdid)))
+		return false;
+
+	pos = GetTuplePositionByKeyAttr(inmemrel, Anum_pg_attrdef_adrelid, attrdid, InvalidAttrNumber, 0);
+
+	return BlockNumberIsValid(pos);
+}
+
+static bool
+TypeInMemCatalog(Datum typeid)
+{
+	InMemHeapRelation inmemrel = OidGetInMemHeapRelation(TypeRelationId, INMEM_ONLY_MAPPING);
+	uint32		pos;
+
+	if (!inmemrel || !OidIsValid(DatumGetObjectId(typeid)))
+		return false;
+
+	pos = GetTuplePositionByKeyAttr(inmemrel, Anum_pg_type_oid, typeid, InvalidAttrNumber, 0);
+
+	return BlockNumberIsValid(pos);
+}
+
+static bool
+RelationInMemCatalog(Datum relid)
+{
+	InMemHeapRelation inmemrel = OidGetInMemHeapRelation(RelationRelationId, INMEM_ONLY_MAPPING);
+	uint32		pos;
+
+	if (!inmemrel || !OidIsValid(DatumGetObjectId(relid)))
+		return false;
+
+	pos = GetTuplePositionByKeyAttr(inmemrel, Anum_pg_class_oid, relid, InvalidAttrNumber, 0);
+
+	return BlockNumberIsValid(pos);
+}
+
+static bool
+ConstraintInMemCatalog(Datum cid)
+{
+	InMemHeapRelation inmemrel = OidGetInMemHeapRelation(ConstraintRelationId, INMEM_ONLY_MAPPING);
+	uint32		pos;
+
+	if (!inmemrel || !OidIsValid(DatumGetObjectId(cid)))
+		return false;
+
+	pos = GetTuplePositionByKeyAttr(inmemrel, Anum_pg_constraint_oid, cid, InvalidAttrNumber, 0);
+
+	return BlockNumberIsValid(pos);
+}
+
+static bool
+IndexInMemCatalog(Datum indexid)
+{
+	InMemHeapRelation inmemrel = OidGetInMemHeapRelation(IndexRelationId, INMEM_ONLY_MAPPING);
+	uint32		pos;
+
+	if (!inmemrel || !OidIsValid(DatumGetObjectId(indexid)))
+		return false;
+
+	pos = GetTuplePositionByKeyAttr(inmemrel, Anum_pg_index_indexrelid, indexid, InvalidAttrNumber, 0);
+
+	return BlockNumberIsValid(pos);
+}
+
+static uint32
+GetTuplePositionByKeyAttr(InMemHeapRelation inmemrel, AttrNumber keyattr1, Datum key1, AttrNumber keyattr2, Datum key2)
+{
+	TupleDesc	tupleDesc;
+	int			i;
+	uint32		pos = InvalidBlockNumber;
+
+	if (IsBootstrapProcessingMode())
+		return InvalidBlockNumber;
+
+	if (!inmemrel)
+		return InvalidBlockNumber;
+
+	Assert(AttributeNumberIsValid(keyattr1));
+	tupleDesc = inmemrel->tupledesc;
+	for (i = 0; i < inmemrel->tupsize; i++)
+	{
+		Datum		tmp1;
+
+		if (inmemrel->tuples[i].flags == INMEM_HEAP_TUPLE_IS_NULL)
+		{
+			Assert(list_member_oid(inmemrel->freelist, i));
+			continue;
+		}
+
+		tmp1 = tuple_getattr(inmemrel->tuples[i].tuple, tupleDesc, keyattr1);
+		if (AttributeNumberIsValid(keyattr2))
+		{
+			Datum		tmp2 = tuple_getattr(inmemrel->tuples[i].tuple, tupleDesc, keyattr2);
+
+			if (tmp1 == key1 && tmp2 == key2)
+			{
+				pos = i;
+				break;
+			}
+		}
+		else if (tmp1 == key1)
+		{
+			pos = i;
+			break;
+		}
+	}
+
+	return pos;
+}
+
+uint32
+GetMemTuplePosition(Relation relation, ItemPointer tid)
+{
+	uint32		pos;
+	Oid			relid = RelationGetRelid(relation);
+	InMemHeapRelation inmemrel = OidGetInMemHeapRelation(relid, INMEM_ONLY_MAPPING);
+
+	if (!IsCatalogRelation(relation))
+		return InvalidBlockNumber;
+
+	if (IsToastRelation(relation))
+		return InvalidBlockNumber;
+
+	if (ItemPointerGetOffsetNumber(tid) != MaxOffsetNumber)
+		return InvalidBlockNumber;
+
+	pos = ItemPointerGetBlockNumber(tid);
+	Assert(!inmemrel || inmemrel->tuples[pos].flags == INMEM_HEAP_TUPLE_DISPATCHED);
+
+	return pos;
+}
+
+static uint32
+AllocInMemoryCatalogInsertPosition(InMemHeapRelation inmemrel)
+{
+	uint32		insert_pos;
+
+	Assert(inmemrel);
+	Assert(CurrentMemoryContext == inmemrel->memcxt);
+	if (inmemrel->freelist != NIL)
+	{
+		uint32		free_pos = linitial_oid(inmemrel->freelist);
+
+		Assert(inmemrel->tuples[free_pos].flags == INMEM_HEAP_TUPLE_IS_NULL);
+		inmemrel->freelist = list_delete_oid(inmemrel->freelist, free_pos);
+		insert_pos = free_pos;
+	}
+	else
+	{
+		if (inmemrel->tupsize >= inmemrel->tupmaxsize)
+		{
+			Assert(NULL != inmemrel->tuples);
+			inmemrel->tuples = repalloc(inmemrel->tuples,
+										sizeof(InMemHeapTupleData) * inmemrel->tupmaxsize * 2);
+			inmemrel->tupmaxsize *= 2;
+		}
+		insert_pos = inmemrel->tupsize;
+		inmemrel->tupsize++;
+	}
+
+	Assert(BlockNumberIsValid(insert_pos));
+
+	return insert_pos;
+}
+
+bool
+CatalogMaybeStoreInMem(Relation rel)
+{
+	return IsCatalogRelation(rel) && (RelationGetRelid(rel) != PublicationNamespaceRelationId);
+}
+
+static bool
+tuple_has_oid(HeapTuple tuple)
+{
+	HeapTupleHeader tup = tuple->t_data;
+
+	if (tup->t_infomask & HEAP_HASOID_OLD)
+		return true;
+	else
+		return false;
+}
diff --git a/src/backend/commands/explain.c b/src/backend/commands/explain.c
index 5334c503e1..fb793a6a5c 100644
--- a/src/backend/commands/explain.c
+++ b/src/backend/commands/explain.c
@@ -1106,6 +1106,7 @@ ExplainPreScanNode(PlanState *planstate, Bitmapset **rels_used)
 
 	switch (nodeTag(plan))
 	{
+		case T_InmemCatalogScan:
 		case T_SeqScan:
 		case T_SampleScan:
 		case T_IndexScan:
@@ -1258,6 +1259,9 @@ ExplainNode(PlanState *planstate, List *ancestors,
 		case T_SeqScan:
 			pname = sname = "Seq Scan";
 			break;
+		case T_InmemCatalogScan:
+			pname = sname  = "InmemCatalog Scan";
+			break;
 		case T_SampleScan:
 			pname = sname = "Sample Scan";
 			break;
@@ -1481,6 +1485,7 @@ ExplainNode(PlanState *planstate, List *ancestors,
 
 	switch (nodeTag(plan))
 	{
+		case T_InmemCatalogScan:
 		case T_SeqScan:
 		case T_SampleScan:
 		case T_BitmapHeapScan:
@@ -1826,6 +1831,7 @@ ExplainNode(PlanState *planstate, List *ancestors,
 							 planstate, ancestors, es);
 			/* fall through to print additional fields the same as SeqScan */
 			/* FALLTHROUGH */
+		case T_InmemCatalogScan:
 		case T_SeqScan:
 		case T_ValuesScan:
 		case T_CteScan:
@@ -3813,6 +3819,7 @@ ExplainTargetRel(Plan *plan, Index rti, ExplainState *es)
 
 	switch (nodeTag(plan))
 	{
+		case T_InmemCatalogScan:
 		case T_SeqScan:
 		case T_SampleScan:
 		case T_IndexScan:
diff --git a/src/backend/executor/Makefile b/src/backend/executor/Makefile
index 11118d0ce0..90aeb48038 100644
--- a/src/backend/executor/Makefile
+++ b/src/backend/executor/Makefile
@@ -75,6 +75,7 @@ OBJS = \
 	nodeValuesscan.o \
 	nodeWindowAgg.o \
 	nodeWorktablescan.o \
+	nodeInmemcatalogscan.o \
 	spi.o \
 	tqueue.o \
 	tstoreReceiver.o
diff --git a/src/backend/executor/execAmi.c b/src/backend/executor/execAmi.c
index 9d18ce8c6b..d575f9b1f3 100644
--- a/src/backend/executor/execAmi.c
+++ b/src/backend/executor/execAmi.c
@@ -58,6 +58,7 @@
 #include "executor/nodeValuesscan.h"
 #include "executor/nodeWindowAgg.h"
 #include "executor/nodeWorktablescan.h"
+#include "executor/nodeInmemcatalogscan.h"
 #include "nodes/extensible.h"
 #include "nodes/nodeFuncs.h"
 #include "nodes/pathnodes.h"
@@ -167,6 +168,10 @@ ExecReScan(PlanState *node)
 			ExecReScanSeqScan((SeqScanState *) node);
 			break;
 
+		case T_InmemCatalogScanState:
+			ExecReScanInmemCatalogScan((InmemCatalogScanState *) node);
+			break;
+
 		case T_SampleScanState:
 			ExecReScanSampleScan((SampleScanState *) node);
 			break;
@@ -568,6 +573,7 @@ ExecSupportsBackwardScan(Plan *node)
 				return true;
 			return false;
 
+		case T_InmemCatalogScan:
 		case T_SeqScan:
 		case T_TidScan:
 		case T_TidRangeScan:
diff --git a/src/backend/executor/execCurrent.c b/src/backend/executor/execCurrent.c
index 96c4bfb6ad..314e2145eb 100644
--- a/src/backend/executor/execCurrent.c
+++ b/src/backend/executor/execCurrent.c
@@ -330,6 +330,7 @@ search_plan_tree(PlanState *node, Oid table_oid,
 			 * relationship of such a node's current output tuple to the
 			 * children's current outputs.)
 			 */
+		case T_InmemCatalogScanState:
 		case T_SeqScanState:
 		case T_SampleScanState:
 		case T_IndexScanState:
diff --git a/src/backend/executor/execProcnode.c b/src/backend/executor/execProcnode.c
index 4d288bc8d4..259216acb4 100644
--- a/src/backend/executor/execProcnode.c
+++ b/src/backend/executor/execProcnode.c
@@ -116,6 +116,7 @@
 #include "executor/nodeValuesscan.h"
 #include "executor/nodeWindowAgg.h"
 #include "executor/nodeWorktablescan.h"
+#include "executor/nodeInmemcatalogscan.h"
 #include "miscadmin.h"
 #include "nodes/nodeFuncs.h"
 
@@ -211,6 +212,11 @@ ExecInitNode(Plan *node, EState *estate, int eflags)
 												   estate, eflags);
 			break;
 
+		case T_InmemCatalogScan:
+			result = (PlanState *) ExecInitInmemCatalogScan((InmemCatalogScan *) node,
+															estate, eflags);
+			break;
+
 		case T_SampleScan:
 			result = (PlanState *) ExecInitSampleScan((SampleScan *) node,
 													  estate, eflags);
@@ -619,6 +625,10 @@ ExecEndNode(PlanState *node)
 			ExecEndSeqScan((SeqScanState *) node);
 			break;
 
+		case T_InmemCatalogScanState:
+			ExecEndInmemCatalogScan((InmemCatalogScanState *) node);
+			break;
+
 		case T_SampleScanState:
 			ExecEndSampleScan((SampleScanState *) node);
 			break;
diff --git a/src/backend/executor/nodeInmemcatalogscan.c b/src/backend/executor/nodeInmemcatalogscan.c
new file mode 100644
index 0000000000..15443a9a62
--- /dev/null
+++ b/src/backend/executor/nodeInmemcatalogscan.c
@@ -0,0 +1,203 @@
+/*-------------------------------------------------------------------------
+ *
+ * nodeInmemcatalogscan.c
+ *	  Support routines for inmem catalog scans of relations.
+ *
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
+ * Portions Copyright (c) 1994, Regents of the University of California
+ *
+ *
+ * IDENTIFICATION
+ *	  src/backend/executor/nodeInmemcatalogscan.c
+ *
+ *-------------------------------------------------------------------------
+ */
+/*
+ * INTERFACE ROUTINES
+ *		ExecSeqScan				sequentially scans a relation.
+ *		ExecSeqNext				retrieve next tuple in sequential order.
+ *		ExecInitSeqScan			creates and initializes a seqscan node.
+ *		ExecEndSeqScan			releases any storage allocated.
+ *		ExecReScanSeqScan		rescans the relation
+ *
+ */
+#include "postgres.h"
+
+#include "access/relscan.h"
+#include "access/tableam.h"
+#include "catalog/inmemcatalog.h"
+#include "executor/execdebug.h"
+#include "executor/nodeInmemcatalogscan.h"
+#include "utils/rel.h"
+
+static TupleTableSlot *InmemCatalogScanNext(InmemCatalogScanState * node);
+
+/* ----------------------------------------------------------------
+ *						Scan Support
+ * ----------------------------------------------------------------
+ */
+
+/* ----------------------------------------------------------------
+ *		SeqNext
+ *
+ *		This is a workhorse for ExecSeqScan
+ * ----------------------------------------------------------------
+ */
+static TupleTableSlot *
+InmemCatalogScanNext(InmemCatalogScanState * node)
+{
+	TableScanDesc scandesc;
+	EState	   *estate;
+	ScanDirection direction;
+	TupleTableSlot *slot;
+
+	scandesc = node->ss.ss_currentScanDesc;
+	estate = node->ss.ps.state;
+	direction = estate->es_direction;
+	slot = node->ss.ss_ScanTupleSlot;
+
+	if (scandesc == NULL)
+	{
+		InMemHeapRelation memheap;
+
+		scandesc = palloc0(sizeof(TableScanDescData));
+		memheap = OidGetInMemHeapRelation(RelationGetRelid(node->ss.ss_currentRelation), INMEM_ONLY_MAPPING);
+		if (memheap)
+			scandesc->inmemonlyscan = InMemHeap_BeginScan(memheap, 0, NULL, NULL, true, estate->es_snapshot, NULL, false);
+
+		node->ss.ss_currentScanDesc = scandesc;
+	}
+
+	if (scandesc->inmemonlyscan != NULL)
+		scandesc->inmem_started = true;
+
+	if (scandesc->inmem_started)
+	{
+		HeapTuple	htup = InMemHeap_GetNext(scandesc->inmemonlyscan, direction);
+
+		if (htup)
+		{
+			if (in_memory_catalog_log)
+				elog(WARNING, "hint one record from memcatalog %s by InmemCatalogScanNext", RelationGetRelationName(node->ss.ss_currentRelation));
+
+			ExecForceStoreHeapTuple(htup, slot, false);
+			return slot;
+		}
+	}
+
+	return NULL;
+}
+
+static bool
+InmemCatalogScanRecheck(InmemCatalogScanState * node, TupleTableSlot *slot)
+{
+	return true;
+}
+
+static TupleTableSlot *
+ExecInmemCatalogScan(PlanState *pstate)
+{
+	InmemCatalogScanState *node = castNode(InmemCatalogScanState, pstate);
+
+	return ExecScan(&node->ss,
+					(ExecScanAccessMtd) InmemCatalogScanNext,
+					(ExecScanRecheckMtd) InmemCatalogScanRecheck);
+}
+
+InmemCatalogScanState *
+ExecInitInmemCatalogScan(InmemCatalogScan * node, EState *estate, int eflags)
+{
+	InmemCatalogScanState *scanstate;
+
+	/*
+	 * Once upon a time it was possible to have an outerPlan of a SeqScan, but
+	 * not any more.
+	 */
+	Assert(outerPlan(node) == NULL);
+	Assert(innerPlan(node) == NULL);
+
+	/*
+	 * create state structure
+	 */
+	scanstate = makeNode(InmemCatalogScanState);
+	scanstate->ss.ps.plan = (Plan *) node;
+	scanstate->ss.ps.state = estate;
+	scanstate->ss.ps.ExecProcNode = ExecInmemCatalogScan;
+
+	/*
+	 * Miscellaneous initialization
+	 *
+	 * create expression context for node
+	 */
+	ExecAssignExprContext(estate, &scanstate->ss.ps);
+
+	/*
+	 * open the scan relation
+	 */
+	scanstate->ss.ss_currentRelation =
+		ExecOpenScanRelation(estate,
+							 node->scan.scanrelid,
+							 eflags);
+
+	/* and create slot with the appropriate rowtype */
+	ExecInitScanTupleSlot(estate, &scanstate->ss,
+						  RelationGetDescr(scanstate->ss.ss_currentRelation),
+						  table_slot_callbacks(scanstate->ss.ss_currentRelation));
+
+	/*
+	 * Initialize result type and projection.
+	 */
+	ExecInitResultTypeTL(&scanstate->ss.ps);
+	ExecAssignScanProjectionInfo(&scanstate->ss);
+
+	/*
+	 * initialize child expressions
+	 */
+	scanstate->ss.ps.qual =
+		ExecInitQual(node->scan.plan.qual, (PlanState *) scanstate);
+
+	return scanstate;
+}
+
+void
+ExecEndInmemCatalogScan(InmemCatalogScanState * node)
+{
+	TableScanDesc scanDesc;
+
+	scanDesc = node->ss.ss_currentScanDesc;
+
+	ExecFreeExprContext(&node->ss.ps);
+
+	if (node->ss.ps.ps_ResultTupleSlot)
+		ExecClearTuple(node->ss.ps.ps_ResultTupleSlot);
+
+	ExecClearTuple(node->ss.ss_ScanTupleSlot);
+
+	if (scanDesc != NULL)
+	{
+		if (scanDesc->inmemonlyscan)
+		{
+			InMemHeap_EndScan(scanDesc->inmemonlyscan, false);
+			scanDesc->inmemonlyscan = NULL;
+		}
+		pfree(scanDesc);
+	}
+}
+
+void
+ExecReScanInmemCatalogScan(InmemCatalogScanState * node)
+{
+	TableScanDesc scan;
+
+	scan = node->ss.ss_currentScanDesc;
+
+	if (scan != NULL &&
+		scan->inmemonlyscan &&
+		scan->inmem_started)
+	{
+		InMemHeap_ReScan(scan->inmemonlyscan, NULL, 0);
+		scan->inmem_started = false;
+	}
+
+	ExecScanReScan((ScanState *) node);
+}
diff --git a/src/backend/optimizer/path/allpaths.c b/src/backend/optimizer/path/allpaths.c
index 9bdc70c702..18196a3105 100644
--- a/src/backend/optimizer/path/allpaths.c
+++ b/src/backend/optimizer/path/allpaths.c
@@ -1268,10 +1268,20 @@ set_append_rel_pathlist(PlannerInfo *root, RelOptInfo *rel,
 		if (!rel->consider_parallel)
 			childrel->consider_parallel = false;
 
-		/*
-		 * Compute the child's access paths.
-		 */
-		set_rel_pathlist(root, childrel, childRTindex, childRTE);
+		if (childrel->inmem_catalog)
+		{
+			Path	*path = create_seqscan_path(root, childrel, childrel->lateral_relids, 0);
+
+			add_path(childrel, path);
+			set_cheapest(childrel);
+		}
+		else
+		{
+			/*
+			 * Compute the child's access paths.
+			 */
+			set_rel_pathlist(root, childrel, childRTindex, childRTE);
+		}
 
 		/*
 		 * If child is dummy, ignore it.
@@ -4423,6 +4433,9 @@ print_path(PlannerInfo *root, Path *path, int indent)
 		case T_Path:
 			switch (path->pathtype)
 			{
+				case T_InmemCatalogScan:
+					ptype = "InmemCatalogScan";
+					break;
 				case T_SeqScan:
 					ptype = "SeqScan";
 					break;
diff --git a/src/backend/optimizer/plan/createplan.c b/src/backend/optimizer/plan/createplan.c
index 4bb38160b3..359294baed 100644
--- a/src/backend/optimizer/plan/createplan.c
+++ b/src/backend/optimizer/plan/createplan.c
@@ -178,6 +178,7 @@ static void copy_plan_costsize(Plan *dest, Plan *src);
 static void label_sort_with_costsize(PlannerInfo *root, Sort *plan,
 									 double limit_tuples);
 static SeqScan *make_seqscan(List *qptlist, List *qpqual, Index scanrelid);
+static InmemCatalogScan *make_inmemcatalogscan(List *qptlist, List *qpqual, Index scanrelid);
 static SampleScan *make_samplescan(List *qptlist, List *qpqual, Index scanrelid,
 								   TableSampleClause *tsc);
 static IndexScan *make_indexscan(List *qptlist, List *qpqual, Index scanrelid,
@@ -2919,9 +2920,12 @@ create_seqscan_plan(PlannerInfo *root, Path *best_path,
 			replace_nestloop_params(root, (Node *) scan_clauses);
 	}
 
-	scan_plan = make_seqscan(tlist,
-							 scan_clauses,
-							 scan_relid);
+	if (best_path->parent->inmem_catalog)
+		scan_plan = (SeqScan *)make_inmemcatalogscan(tlist, scan_clauses, scan_relid);
+	else
+		scan_plan = make_seqscan(tlist,
+								 scan_clauses,
+								 scan_relid);
 
 	copy_generic_path_info(&scan_plan->scan.plan, best_path);
 
@@ -5479,6 +5483,23 @@ make_seqscan(List *qptlist,
 	return node;
 }
 
+static InmemCatalogScan *
+make_inmemcatalogscan(List *qptlist,
+			 List *qpqual,
+			 Index scanrelid)
+{
+	InmemCatalogScan	*node = makeNode(InmemCatalogScan);
+	Plan				*plan = &node->scan.plan;
+
+	plan->targetlist = qptlist;
+	plan->qual = qpqual;
+	plan->lefttree = NULL;
+	plan->righttree = NULL;
+	node->scan.scanrelid = scanrelid;
+
+	return node;
+}
+
 static SampleScan *
 make_samplescan(List *qptlist,
 				List *qpqual,
diff --git a/src/backend/optimizer/plan/initsplan.c b/src/backend/optimizer/plan/initsplan.c
index 06f90882c4..362c6e70fb 100644
--- a/src/backend/optimizer/plan/initsplan.c
+++ b/src/backend/optimizer/plan/initsplan.c
@@ -14,8 +14,10 @@
  */
 #include "postgres.h"
 
+#include "catalog/catalog.h"
 #include "catalog/pg_class.h"
 #include "catalog/pg_type.h"
+#include "catalog/inmemcatalog.h"
 #include "nodes/makefuncs.h"
 #include "nodes/nodeFuncs.h"
 #include "optimizer/clauses.h"
@@ -208,6 +210,11 @@ add_other_rels_to_query(PlannerInfo *root)
 		if (rel->reloptkind != RELOPT_BASEREL)
 			continue;
 
+		if (rte->rtekind == RTE_RELATION &&
+			IsCatalogRelationOid(rte->relid) &&
+			OidGetInMemHeapRelation(rte->relid, INMEM_ONLY_MAPPING))
+			rte->inh = true;
+
 		/* If it's marked as inheritable, look for children. */
 		if (rte->inh)
 			expand_inherited_rtentry(root, rel, rte, rti);
diff --git a/src/backend/optimizer/plan/setrefs.c b/src/backend/optimizer/plan/setrefs.c
index f6f8a79354..88a0657710 100644
--- a/src/backend/optimizer/plan/setrefs.c
+++ b/src/backend/optimizer/plan/setrefs.c
@@ -623,6 +623,7 @@ set_plan_refs(PlannerInfo *root, Plan *plan, int rtoffset)
 	switch (nodeTag(plan))
 	{
 		case T_SeqScan:
+		case T_InmemCatalogScan:
 			{
 				SeqScan    *splan = (SeqScan *) plan;
 
diff --git a/src/backend/optimizer/plan/subselect.c b/src/backend/optimizer/plan/subselect.c
index 5f12b2ef9b..f5f514ad40 100644
--- a/src/backend/optimizer/plan/subselect.c
+++ b/src/backend/optimizer/plan/subselect.c
@@ -2317,6 +2317,7 @@ finalize_plan(PlannerInfo *root, Plan *plan,
 			break;
 
 		case T_SeqScan:
+		case T_InmemCatalogScan:
 			context.paramids = bms_add_members(context.paramids, scan_params);
 			break;
 
diff --git a/src/backend/optimizer/util/inherit.c b/src/backend/optimizer/util/inherit.c
index bae9688e46..9308311d10 100644
--- a/src/backend/optimizer/util/inherit.c
+++ b/src/backend/optimizer/util/inherit.c
@@ -14,6 +14,7 @@
  */
 #include "postgres.h"
 
+#include "catalog/catalog.h"
 #include "access/sysattr.h"
 #include "access/table.h"
 #include "catalog/partition.h"
@@ -165,9 +166,19 @@ expand_inherited_rtentry(PlannerInfo *root, RelOptInfo *rel,
 		 */
 		List	   *inhOIDs;
 		ListCell   *l;
+		bool		add_inmemcatalog_scan = false;
+		bool		first = true;
 
-		/* Scan for all members of inheritance set, acquire needed locks */
-		inhOIDs = find_all_inheritors(parentOID, lockmode, NULL);
+		if (IsCatalogRelationOid(rte->relid))
+		{
+			inhOIDs = list_make2_oid(rte->relid, rte->relid);
+			add_inmemcatalog_scan = true;
+		}
+		else
+		{
+			/* Scan for all members of inheritance set, acquire needed locks */
+			inhOIDs = find_all_inheritors(parentOID, lockmode, NULL);
+		}
 
 		/*
 		 * We used to special-case the situation where the table no longer has
@@ -193,6 +204,16 @@ expand_inherited_rtentry(PlannerInfo *root, RelOptInfo *rel,
 			Relation	newrelation;
 			RangeTblEntry *childrte;
 			Index		childRTindex;
+			bool		inmem_rel = false;
+			RelOptInfo	*child_rel;
+
+			if (first)
+				first = false;
+			else if (add_inmemcatalog_scan)
+			{
+				Assert(IsCatalogRelationOid(childOID));
+				inmem_rel = true;
+			}
 
 			/* Open rel if needed; we already have required locks */
 			if (childOID != parentOID)
@@ -218,7 +239,9 @@ expand_inherited_rtentry(PlannerInfo *root, RelOptInfo *rel,
 											&childrte, &childRTindex);
 
 			/* Create the otherrel RelOptInfo too. */
-			(void) build_simple_rel(root, childRTindex, rel);
+			child_rel = build_simple_rel(root, childRTindex, rel);
+
+			child_rel->inmem_catalog = inmem_rel;
 
 			/* Close child relations, but keep locks */
 			if (childOID != parentOID)
diff --git a/src/backend/optimizer/util/relnode.c b/src/backend/optimizer/util/relnode.c
index 68fd033595..e312dde602 100644
--- a/src/backend/optimizer/util/relnode.c
+++ b/src/backend/optimizer/util/relnode.c
@@ -283,6 +283,7 @@ build_simple_rel(PlannerInfo *root, int relid, RelOptInfo *parent)
 	rel->all_partrels = NULL;
 	rel->partexprs = NULL;
 	rel->nullable_partexprs = NULL;
+	rel->inmem_catalog = false;
 
 	/*
 	 * Pass assorted information down the inheritance hierarchy.
diff --git a/src/backend/utils/cache/catcache.c b/src/backend/utils/cache/catcache.c
index 4510031fe6..27861cf51d 100644
--- a/src/backend/utils/cache/catcache.c
+++ b/src/backend/utils/cache/catcache.c
@@ -1365,6 +1365,13 @@ SearchCatCacheMiss(CatCache *cache,
 		ct = CatalogCacheCreateEntry(cache, ntp, arguments,
 									 hashValue, hashIndex,
 									 false);
+
+#ifndef CATCACHE_FORCE_RELEASE
+		/* Make sure tuple is removed during ReleaseCatCache */
+		if (scandesc->inmem_started)
+			ct->dead = true;
+#endif
+
 		/* immediately set the refcount to 1 */
 		ResourceOwnerEnlargeCatCacheRefs(CurrentResourceOwner);
 		ct->refcount++;
diff --git a/src/backend/utils/misc/guc_tables.c b/src/backend/utils/misc/guc_tables.c
index 5f90aecd47..bc025f0256 100644
--- a/src/backend/utils/misc/guc_tables.c
+++ b/src/backend/utils/misc/guc_tables.c
@@ -36,6 +36,7 @@
 #include "archive/archive_module.h"
 #include "catalog/namespace.h"
 #include "catalog/storage.h"
+#include "catalog/inmemcatalog.h"
 #include "commands/async.h"
 #include "commands/tablespace.h"
 #include "commands/trigger.h"
@@ -2002,6 +2003,15 @@ struct config_bool ConfigureNamesBool[] =
 		NULL, NULL, NULL
 	},
 
+	{
+		{"in_memory_catalog_log", PGC_USERSET, UNGROUPED,
+			gettext_noop("log in memory catalog."),
+		},
+		&in_memory_catalog_log,
+		false,
+		NULL, NULL, NULL
+	},
+
 	/* End-of-list marker */
 	{
 		{NULL, 0, 0, NULL, NULL}, NULL, false, NULL, NULL, NULL
diff --git a/src/backend/utils/misc/postgresql.conf.sample b/src/backend/utils/misc/postgresql.conf.sample
index 11a4cf6cfb..3596aacd40 100644
--- a/src/backend/utils/misc/postgresql.conf.sample
+++ b/src/backend/utils/misc/postgresql.conf.sample
@@ -817,4 +817,6 @@
 # CUSTOMIZED OPTIONS
 #------------------------------------------------------------------------------
 
+#in_memory_catalog_log = off
+
 # Add settings for extensions here
diff --git a/src/include/access/heapam.h b/src/include/access/heapam.h
index faf5026519..1ae296e659 100644
--- a/src/include/access/heapam.h
+++ b/src/include/access/heapam.h
@@ -280,7 +280,13 @@ extern void simple_heap_update(Relation relation, ItemPointer otid,
 
 extern TransactionId heap_index_delete_tuples(Relation rel,
 											  TM_IndexDeleteOp *delstate);
-
+extern HeapTuple heap_prepare_insert(Relation relation, HeapTuple tup,
+									 TransactionId xid, CommandId cid, int options);;
+extern void compute_new_xmax_infomask(TransactionId xmax, uint16 old_infomask,
+									  uint16 old_infomask2, TransactionId add_to_xmax,
+									  LockTupleMode mode, bool is_update,
+									  TransactionId *result_xmax, uint16 *result_infomask,
+									  uint16 *result_infomask2);
 /* in heap/pruneheap.c */
 struct GlobalVisState;
 extern void heap_page_prune_opt(Relation relation, Buffer buffer);
diff --git a/src/include/access/relscan.h b/src/include/access/relscan.h
index d03360eac0..37a52cad40 100644
--- a/src/include/access/relscan.h
+++ b/src/include/access/relscan.h
@@ -21,6 +21,7 @@
 #include "storage/spin.h"
 #include "utils/relcache.h"
 
+typedef struct InMemHeapScanDescData *InMemHeapScanDesc;
 
 struct ParallelTableScanDescData;
 
@@ -48,6 +49,9 @@ typedef struct TableScanDescData
 
 	struct ParallelTableScanDescData *rs_parallel;	/* parallel scan
 													 * information */
+
+	InMemHeapScanDesc	inmemonlyscan;
+	bool				inmem_started;
 } TableScanDescData;
 typedef struct TableScanDescData *TableScanDesc;
 
@@ -186,6 +190,9 @@ typedef struct SysScanDescData
 	struct IndexScanDescData *iscan;	/* only valid in index-scan case */
 	struct SnapshotData *snapshot;	/* snapshot to unregister at end of scan */
 	struct TupleTableSlot *slot;
+
+	InMemHeapScanDesc inmemonlyscan; /* scan of in-memory entries that are not saved to disk */
+	bool		inmem_started; /* heap/index scan finished, start inmemonlyscan */
 }			SysScanDescData;
 
 #endif							/* RELSCAN_H */
diff --git a/src/include/access/tableam.h b/src/include/access/tableam.h
index b19d50ecc2..839dda23b7 100644
--- a/src/include/access/tableam.h
+++ b/src/include/access/tableam.h
@@ -20,6 +20,7 @@
 #include "access/relscan.h"
 #include "access/sdir.h"
 #include "access/xact.h"
+#include "catalog/inmemcatalog.h"
 #include "executor/tuptable.h"
 #include "utils/rel.h"
 #include "utils/snapshot.h"
@@ -1008,6 +1009,12 @@ table_beginscan_analyze(Relation rel)
 static inline void
 table_endscan(TableScanDesc scan)
 {
+	if (scan->inmemonlyscan)
+	{
+		InMemHeap_EndScan(scan->inmemonlyscan, false);
+		scan->inmemonlyscan = NULL;
+	}
+
 	scan->rs_rd->rd_tableam->scan_end(scan);
 }
 
diff --git a/src/include/catalog/inmemcatalog.h b/src/include/catalog/inmemcatalog.h
new file mode 100644
index 0000000000..95f0cb9fea
--- /dev/null
+++ b/src/include/catalog/inmemcatalog.h
@@ -0,0 +1,132 @@
+/*-------------------------------------------------------------------------
+ *
+ * inmemcatalog.h
+ *	 in-memory heap table access method
+ *
+ *
+ *-------------------------------------------------------------------------
+ */
+
+#ifndef _INMEMCATALOG_H_
+#define _INMEMCATALOG_H_
+
+#include "access/htup.h"
+#include "access/relscan.h"
+#include "access/skey.h"
+#include "access/sdir.h"
+#include "storage/lockdefs.h"
+#include "nodes/primnodes.h"
+#include "nodes/execnodes.h"
+#include "utils/relcache.h"
+#include "utils/hsearch.h"
+#include "utils/snapshot.h"
+
+extern bool in_memory_catalog_log;
+
+/*
+ * In memory storage types. When creating/accessing/dropping tables,
+ * the mapping type needs to be specified.
+ */
+enum InMemMappingType
+{
+	INMEM_ONLY_MAPPING = 0,		/* Tuples that are only kept in memory and do
+								 * not have a copy on disk. (e.g. HCatalog) */
+	INMEM_MAPPINGS_SIZE			/* Number of mappings - keep last. */
+};
+typedef enum InMemMappingType InMemMappingType;
+
+enum InMemHeapTupleFlag
+{
+	INMEM_HEAP_TUPLE_IS_NULL = 1,
+	INMEM_HEAP_TUPLE_DISPATCHED
+};
+typedef enum InMemHeapTupleFlag InMemHeapTupleFlag;
+
+struct InMemHeapTupleData
+{
+	HeapTuple	tuple;			/* heap tuple */
+	uint8		flags;			/* tuple flag such as INMEM_HEAP_TUPLE_DELETED */
+};
+typedef struct InMemHeapTupleData InMemHeapTupleData;
+
+typedef struct InMemHeapTupleData *InMemHeapTuple;
+
+struct InMemHeapRelationData
+{
+	MemoryContext memcxt;
+	InMemHeapTuple tuples;		/* a vector of InMemHeapTuple */
+	TupleDesc	tupledesc;
+	int32		tupsize;
+	int32		tupmaxsize;
+	Oid			relid;
+	char		relname[NAMEDATALEN];
+	HTAB	   *hashIndex;		/* build a hash index for fast lookup */
+	int			keyAttrno;		/* attribute no of hash index key, key must be
+								 * Oid type */
+	List	   *freelist;
+};
+typedef struct InMemHeapRelationData InMemHeapRelationData;
+typedef struct InMemHeapRelationData *InMemHeapRelation;
+
+extern HTAB *OidInMemMappings[INMEM_MAPPINGS_SIZE];
+
+struct OidInMemHeapMappingEntry
+{
+	Oid			relid;
+	InMemHeapRelation rel;
+};
+
+typedef struct InMemHeapScanDescData
+{
+	InMemHeapRelation rs_rd;	/* heap relation descriptor */
+	struct SnapshotData *rs_snapshot;
+	int			rs_nkeys;		/* number of scan keys */
+	ScanKey		rs_key;			/* array of scan key descriptors */
+	AttrNumber *orig_attnos;
+
+	/* scan current state */
+	HeapTuple	rs_ctup;		/* current tuple in scan, if any */
+	int32		rs_index;		/* current tuple position in in-memory heap
+								 * table */
+
+	IndexInfo  *index_info;
+
+#if 0
+	TableScanDesc hscan;		/* if there is a heap table with the same Oid,
+								 * this a heap scan descriptor */
+
+	Oid			indexScanKey;	/* hash key searched in hash table */
+	bool		hashIndexOk;	/* hash index is ok to use */
+	bool		indexScanInitialized;	/* hash index scan has initialized */
+	int			hashKeyIndexInScanKey;	/* the index of hash key in scan key
+										 * array */
+	ListCell   *indexNext;		/* cursor in hash index */
+	List	   *indexReverseList;	/* reverse list of the scan key for
+									 * backward scan */
+#endif
+}			InMemHeapScanDescData;
+
+typedef InMemHeapScanDescData * InMemHeapScanDesc;
+
+extern void CleanupOidInMemHeapMapping(InMemMappingType mappingType);
+extern InMemHeapRelation OidGetInMemHeapRelation(Oid relid, InMemMappingType mappingType);
+extern InMemHeapRelation InMemHeap_Create(Oid relid, Relation rel,
+										  int32 initSize, const char *relname, bool createIndex, int keyAttrno,
+										  InMemMappingType mappingType);
+extern void InMemHeap_Drop(Oid relid, InMemMappingType mappingType);
+extern void InMemHeap_DropAll(InMemMappingType mappingType);
+extern InMemHeapScanDesc InMemHeap_BeginScan(InMemHeapRelation memheap,
+											 int nkeys, ScanKey key, AttrNumber *orig_attnos, bool inmemonly,
+											 Snapshot snapshot, Relation index, bool addref);
+extern void InMemHeap_ReScan(InMemHeapScanDesc scan, ScanKey keys, int nkeys);
+extern void InMemHeap_EndScan(InMemHeapScanDesc scan, bool closerel);
+extern HeapTuple InMemHeap_GetNext(InMemHeapScanDesc scan, ScanDirection direction);
+extern void InMemHeap_Insert(Relation relation, HeapTuple tup);
+extern void InMemHeap_Update(Relation relation, HeapTuple tup, uint32 position, bool inplace);
+extern void InMemHeap_Delete(Relation relation, uint32 position);
+extern bool IsTupleShouldStoreInMemCatalog(Relation relation, HeapTuple newTuple);
+extern Datum tuple_getattr(HeapTuple tuple, TupleDesc tupleDesc, int attnum);
+extern uint32 GetMemTuplePosition(Relation relation, ItemPointer tid);
+extern bool CatalogMaybeStoreInMem(Relation rel);
+
+#endif							/* _INMEMCATALOG_H_ */
diff --git a/src/include/executor/nodeInmemcatalogscan.h b/src/include/executor/nodeInmemcatalogscan.h
new file mode 100644
index 0000000000..84600e6249
--- /dev/null
+++ b/src/include/executor/nodeInmemcatalogscan.h
@@ -0,0 +1,24 @@
+/*-------------------------------------------------------------------------
+ *
+ * nodeInmemcatalogscan
+ *
+ *
+ *
+ * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
+ * Portions Copyright (c) 1994, Regents of the University of California
+ *
+ * src/include/executor/nodeInmemcatalogscan.h
+ *
+ *-------------------------------------------------------------------------
+ */
+#ifndef NODEINMEMCATALOGSCAN_H
+#define NODEINMEMCATALOGSCAN_H 
+
+#include "access/parallel.h"
+#include "nodes/execnodes.h"
+
+extern InmemCatalogScanState *ExecInitInmemCatalogScan(InmemCatalogScan *node, EState *estate, int eflags);
+extern void ExecEndInmemCatalogScan(InmemCatalogScanState *node);
+extern void ExecReScanInmemCatalogScan(InmemCatalogScanState *node);
+
+#endif							/* NODESEQSCAN_H */
diff --git a/src/include/nodes/execnodes.h b/src/include/nodes/execnodes.h
index 61b3517906..27642abde8 100644
--- a/src/include/nodes/execnodes.h
+++ b/src/include/nodes/execnodes.h
@@ -1476,6 +1476,11 @@ typedef struct SeqScanState
 	Size		pscan_len;		/* size of parallel heap scan descriptor */
 } SeqScanState;
 
+typedef struct InmemCatalogScanState
+{
+	ScanState	ss;				/* its first field is NodeTag */
+} InmemCatalogScanState;
+
 /* ----------------
  *	 SampleScanState information
  * ----------------
diff --git a/src/include/nodes/pathnodes.h b/src/include/nodes/pathnodes.h
index 7d4f24d250..437ca32cc7 100644
--- a/src/include/nodes/pathnodes.h
+++ b/src/include/nodes/pathnodes.h
@@ -1019,6 +1019,8 @@ typedef struct RelOptInfo
 	/* Relids set of all partition relids */
 	Relids		all_partrels;
 
+	bool		inmem_catalog;
+
 	/*
 	 * These arrays are of length partkey->partnatts, which we don't have at
 	 * hand, so don't try to print
diff --git a/src/include/nodes/plannodes.h b/src/include/nodes/plannodes.h
index 1b787fe031..9c837752b7 100644
--- a/src/include/nodes/plannodes.h
+++ b/src/include/nodes/plannodes.h
@@ -396,6 +396,11 @@ typedef struct SeqScan
 	Scan		scan;
 } SeqScan;
 
+typedef struct InmemCatalogScan
+{
+	Scan		scan;
+} InmemCatalogScan;
+
 /* ----------------
  *		table sample scan node
  * ----------------
-- 
2.39.2 (Apple Git-143)

